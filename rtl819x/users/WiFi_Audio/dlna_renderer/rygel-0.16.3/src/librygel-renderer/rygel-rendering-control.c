/* rygel-rendering-control.c generated by valac 0.16.1, the Vala compiler
 * generated from rygel-rendering-control.vala, do not modify */

/*
 * Copyright (C) 2008 OpenedHand Ltd.
 * Copyright (C) 2009 Nokia Corporation.
 *
 * Author: Jorn Baayen <jorn@openedhand.com>
 *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
 *                               <zeeshan.ali@nokia.com>
 *
 * Rygel is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Rygel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <libgupnp/gupnp.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>
#include <float.h>
#include <math.h>
#include <rygel-core.h>
#include <glib/gi18n-lib.h>
#include <alsa/asoundlib.h>
#include "wfshm.h"
#include "rygel-libpre.h"
int StartThreadForVolumeControl(void *arg);

pthread_mutex_t VolumeControlState=PTHREAD_MUTEX_INITIALIZER;
int VolumeControlRunning=0;
guint CurrentVolume=0;
guint LastCurrentVolume=0;
guint CurrentDesiredVolume=0;
pthread_t RygelVolumeCtrl;

#define RYGEL_TYPE_RENDERING_CONTROL (rygel_rendering_control_get_type ())
#define RYGEL_RENDERING_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RENDERING_CONTROL, RygelRenderingControl))
#define RYGEL_RENDERING_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RENDERING_CONTROL, RygelRenderingControlClass))
#define RYGEL_IS_RENDERING_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RENDERING_CONTROL))
#define RYGEL_IS_RENDERING_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RENDERING_CONTROL))
#define RYGEL_RENDERING_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RENDERING_CONTROL, RygelRenderingControlClass))

typedef struct _RygelRenderingControl RygelRenderingControl;
typedef struct _RygelRenderingControlClass RygelRenderingControlClass;
typedef struct _RygelRenderingControlPrivate RygelRenderingControlPrivate;

#define RYGEL_TYPE_CHANGE_LOG (rygel_change_log_get_type ())
#define RYGEL_CHANGE_LOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CHANGE_LOG, RygelChangeLog))
#define RYGEL_CHANGE_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CHANGE_LOG, RygelChangeLogClass))
#define RYGEL_IS_CHANGE_LOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CHANGE_LOG))
#define RYGEL_IS_CHANGE_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CHANGE_LOG))
#define RYGEL_CHANGE_LOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CHANGE_LOG, RygelChangeLogClass))

typedef struct _RygelChangeLog RygelChangeLog;
typedef struct _RygelChangeLogClass RygelChangeLogClass;

#define RYGEL_TYPE_MEDIA_PLAYER (rygel_media_player_get_type ())
#define RYGEL_MEDIA_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_PLAYER, RygelMediaPlayer))
#define RYGEL_IS_MEDIA_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_PLAYER))
#define RYGEL_MEDIA_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_MEDIA_PLAYER, RygelMediaPlayerIface))

typedef struct _RygelMediaPlayer RygelMediaPlayer;
typedef struct _RygelMediaPlayerIface RygelMediaPlayerIface;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define RYGEL_TYPE_MEDIA_RENDERER_PLUGIN (rygel_media_renderer_plugin_get_type ())
#define RYGEL_MEDIA_RENDERER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN, RygelMediaRendererPlugin))
#define RYGEL_MEDIA_RENDERER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN, RygelMediaRendererPluginClass))
#define RYGEL_IS_MEDIA_RENDERER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN))
#define RYGEL_IS_MEDIA_RENDERER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN))
#define RYGEL_MEDIA_RENDERER_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN, RygelMediaRendererPluginClass))

typedef struct _RygelMediaRendererPlugin RygelMediaRendererPlugin;
typedef struct _RygelMediaRendererPluginClass RygelMediaRendererPluginClass;

struct _RygelRenderingControl {
	GUPnPService parent_instance;
	RygelRenderingControlPrivate * priv;
};

struct _RygelRenderingControlClass {
	GUPnPServiceClass parent_class;
};

struct _RygelMediaPlayerIface {
	GTypeInterface parent_iface;
	gboolean (*seek) (RygelMediaPlayer* self, GstClockTime time);
	gchar** (*get_protocols) (RygelMediaPlayer* self, int* result_length1);
	gchar** (*get_mime_types) (RygelMediaPlayer* self, int* result_length1);
	gchar* (*get_playback_state) (RygelMediaPlayer* self);
	void (*set_playback_state) (RygelMediaPlayer* self, const gchar* value);
	gchar* (*get_uri) (RygelMediaPlayer* self);
	void (*set_uri) (RygelMediaPlayer* self, const gchar* value);
	gdouble (*get_volume) (RygelMediaPlayer* self);
	void (*set_volume) (RygelMediaPlayer* self, gdouble value);
	gint64 (*get_duration) (RygelMediaPlayer* self);
	gchar* (*get_metadata) (RygelMediaPlayer* self);
	void (*set_metadata) (RygelMediaPlayer* self, const gchar* value);
	gchar* (*get_mime_type) (RygelMediaPlayer* self);
	void (*set_mime_type) (RygelMediaPlayer* self, const gchar* value);
	gchar* (*get_content_features) (RygelMediaPlayer* self);
	void (*set_content_features) (RygelMediaPlayer* self, const gchar* value);
	gint64 (*get_position) (RygelMediaPlayer* self);
};

struct _RygelRenderingControlPrivate {
	gboolean _mute;
	guint _volume;
	gchar* preset_name_list;
	RygelChangeLog* changelog;
	RygelMediaPlayer* player;
};


static gpointer rygel_rendering_control_parent_class = NULL;
RygelRenderingControl * self_renderer_controler=NULL;

GType rygel_rendering_control_get_type (void) G_GNUC_CONST;
GType rygel_change_log_get_type (void) G_GNUC_CONST;
GType rygel_media_player_get_type (void) G_GNUC_CONST;
#define RYGEL_RENDERING_CONTROL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_RENDERING_CONTROL, RygelRenderingControlPrivate))
enum  {
	RYGEL_RENDERING_CONTROL_DUMMY_PROPERTY,
	RYGEL_RENDERING_CONTROL_MUTE,
	RYGEL_RENDERING_CONTROL_VOLUME
};
#define RYGEL_RENDERING_CONTROL_UPNP_ID "urn:upnp-org:serviceId:RenderingControl"
#define RYGEL_RENDERING_CONTROL_UPNP_TYPE "urn:schemas-upnp-org:service:RenderingControl:1"
#define RYGEL_RENDERING_CONTROL_DESCRIPTION_PATH "xml/RenderingControl2.xml"
#define RYGEL_RENDERING_CONTROL_LAST_CHANGE_NS "urn:schemas-upnp-org:metadata-1-0/RCS/"
static void rygel_rendering_control_real_constructed (GObject* base);
RygelChangeLog* rygel_change_log_new (GUPnPService* service, const gchar* service_ns);
RygelChangeLog* rygel_change_log_construct (GType object_type, GUPnPService* service, const gchar* service_ns);
static RygelMediaPlayer* rygel_rendering_control_get_player (RygelRenderingControl* self);
static void rygel_rendering_control_query_last_change_cb (RygelRenderingControl* self, GUPnPService* service, const gchar* variable, GValue* value);
static void _rygel_rendering_control_query_last_change_cb_gupnp_service_query_variable (GUPnPService* _sender, const gchar* variable, GValue* value, gpointer self);
static void rygel_rendering_control_list_presets_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_rendering_control_list_presets_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_rendering_control_select_preset_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_rendering_control_select_preset_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_rendering_control_get_mute_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_rendering_control_get_mute_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_rendering_control_set_mute_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_rendering_control_set_mute_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_rendering_control_get_volume_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_rendering_control_get_volume_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_rendering_control_set_volume_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_rendering_control_set_volume_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
guint rygel_volume_to_percentage (gdouble volume);
gdouble rygel_media_player_get_volume (RygelMediaPlayer* self);
gboolean rygel_rendering_control_get_mute (RygelRenderingControl* self);
void rygel_change_log_log_with_channel (RygelChangeLog* self, const gchar* variable, const gchar* value, const gchar* channel);
guint rygel_rendering_control_get_volume (RygelRenderingControl* self);
gchar* rygel_change_log_finish (RygelChangeLog* self);
GType rygel_media_renderer_plugin_get_type (void) G_GNUC_CONST;
RygelMediaPlayer* rygel_media_renderer_plugin_get_player (RygelMediaRendererPlugin* self);
static gboolean rygel_rendering_control_check_instance_id (RygelRenderingControl* self, GUPnPServiceAction* action);
static gboolean rygel_rendering_control_check_channel (RygelRenderingControl* self, GUPnPServiceAction* action);
void rygel_rendering_control_set_mute (RygelRenderingControl* self, gboolean value);
void rygel_rendering_control_set_volume (RygelRenderingControl* self, guint value);
void rygel_rendering_control_set_volume_sync_hw (RygelRenderingControl* self, guint value);
RygelRenderingControl* rygel_rendering_control_new (void);
RygelRenderingControl* rygel_rendering_control_construct (GType object_type);
void rygel_media_player_set_volume (RygelMediaPlayer* self, gdouble value);
gdouble rygel_volume_from_percentage (guint percentage);
static void rygel_rendering_control_finalize (GObject* obj);
static void _vala_rygel_rendering_control_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_rygel_rendering_control_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void _rygel_rendering_control_query_last_change_cb_gupnp_service_query_variable (GUPnPService* _sender, const gchar* variable, GValue* value, gpointer self) {
	rygel_rendering_control_query_last_change_cb (self, _sender, variable, value);
}


static void _rygel_rendering_control_list_presets_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_rendering_control_list_presets_cb (self, _sender, action);
}


static void _rygel_rendering_control_select_preset_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_rendering_control_select_preset_cb (self, _sender, action);
}


static void _rygel_rendering_control_get_mute_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_rendering_control_get_mute_cb (self, _sender, action);
}


static void _rygel_rendering_control_set_mute_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_rendering_control_set_mute_cb (self, _sender, action);
}


static void _rygel_rendering_control_get_volume_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_rendering_control_get_volume_cb (self, _sender, action);
}


static void _rygel_rendering_control_set_volume_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_rendering_control_set_volume_cb (self, _sender, action);
}

void *RygelVolumeControlThread(void *arg)
{
	double NowVolume=0.0;
	int err=0;
	RygelRenderingControl *self=(RygelRenderingControl*)arg;
	int Check_VolumeControlRunning=0;
	int isNeedUpdateVolume=0;
	int isNeedUpdateVolumeConfirm=0;
	int sleepInterval=980000;
	guint Check_CurrentDesiredVolume=0;
	guint Last_CurrentDesiredVolume=0;
	RygelMediaPlayer* _tmp2_;
	gboolean _tmp1_;
	gdouble _tmp3_=0.0;
	guint _tmp5_ = 0U;
	guint icount=0;
	guint max_loop=7;
	guint vol_step=0;
	guint Remainder=0;
	gdouble expectvalue=0.0;
	_tmp2_ = self->priv->player;
	_tmp3_ = rygel_media_player_get_volume (_tmp2_);
	_tmp5_ = rygel_volume_to_percentage (_tmp3_);
	
	pthread_mutex_lock(&VolumeControlState);
	VolumeControlRunning =1;
	CurrentVolume=_tmp5_;
	CurrentDesiredVolume = CurrentVolume;
	pthread_mutex_unlock(&VolumeControlState);
	//g_print("%d CurrentDesiredVolume=%d\n", __LINE__,CurrentDesiredVolume);
	for(;;){
		pthread_mutex_lock(&VolumeControlState);
		Check_VolumeControlRunning = VolumeControlRunning;
		Check_CurrentDesiredVolume = CurrentDesiredVolume;
		pthread_mutex_unlock(&VolumeControlState);
		
		
		if(Check_VolumeControlRunning == 0)
			break;
#if defined(CONFIG_RTL_PRE_EMPTIVE)
		if(CheckCurrentRight()==0){
			usleep(sleepInterval);
			continue;	
		}
#endif			
		_tmp3_ = rygel_media_player_get_volume (_tmp2_);
		CurrentVolume = rygel_volume_to_percentage (_tmp3_);
		//g_print("%d CurrentDesiredVolume=%d, CurrentVolume=%d\n", __LINE__,CurrentDesiredVolume,CurrentVolume);
		_tmp1_ = rygel_rendering_control_get_mute (self);
		if(!_tmp1_ ){
			if(Check_CurrentDesiredVolume >= 0 && Last_CurrentDesiredVolume != Check_CurrentDesiredVolume){
				icount = 0;
				isNeedUpdateVolume=0;
				if(Check_CurrentDesiredVolume > CurrentVolume){
					if((Check_CurrentDesiredVolume - CurrentVolume) > 5){
						vol_step = (Check_CurrentDesiredVolume - CurrentVolume)/max_loop;
						Remainder= (Check_CurrentDesiredVolume - CurrentVolume)%max_loop;
						//g_print("%d vol_step=%d\n",__LINE__, vol_step);
						isNeedUpdateVolume =1;
					}
				}else if(Check_CurrentDesiredVolume < CurrentVolume){
					if((CurrentVolume - Check_CurrentDesiredVolume ) > 5){
						vol_step = (CurrentVolume - Check_CurrentDesiredVolume)/max_loop;
						Remainder= (CurrentVolume - Check_CurrentDesiredVolume)%max_loop;
						//g_print("%d vol_step=%d\n",__LINE__, vol_step);
						isNeedUpdateVolume =2;
					}
				}
				if(isNeedUpdateVolume == 0){
					expectvalue = rygel_volume_from_percentage (Check_CurrentDesiredVolume);
					//g_print("Check_CurrentDesiredVolume = %d Last_CurrentDesiredVolume = %d\n",Check_CurrentDesiredVolume,  Last_CurrentDesiredVolume);
					//g_print("%d expectvalue=%f, icount=%d\n",__LINE__, expectvalue,icount);
						rygel_media_player_set_volume (_tmp2_,expectvalue);
					vol_step = 1;
				}
			}
			else{
				if(LastCurrentVolume != CurrentVolume && vol_step ==0){
					icount = 0;
					isNeedUpdateVolume=0;
					rygel_rendering_control_set_volume_sync_hw (self, CurrentVolume);
				}
			}
			if(isNeedUpdateVolume ==1){
				expectvalue = rygel_volume_from_percentage ((CurrentVolume+vol_step));
			}else if(isNeedUpdateVolume ==2){
				if(CurrentVolume >= vol_step){
					if(CurrentVolume - vol_step > 0)
						expectvalue = rygel_volume_from_percentage ((CurrentVolume-vol_step));
					else{
						if(Check_CurrentDesiredVolume == 0)
							expectvalue = 0.0;
						else if(Check_CurrentDesiredVolume > 0){
							expectvalue = rygel_volume_from_percentage (CurrentVolume);
						}	
					}
				}else{
					if(Check_CurrentDesiredVolume == 0)
						expectvalue = 0.0;
					else if(Check_CurrentDesiredVolume > 0){
						expectvalue = rygel_volume_from_percentage (CurrentVolume);
					}
				}
			}
				//g_print("CurrentVolume=%d, expectvalue=%f, icount=%d\n",CurrentVolume, expectvalue,icount);
			if(isNeedUpdateVolume !=0){
				if(isNeedUpdateVolume ==1 && CurrentVolume < Check_CurrentDesiredVolume){
					isNeedUpdateVolumeConfirm = 1;
				}else if(isNeedUpdateVolume ==2 && CurrentVolume > Check_CurrentDesiredVolume){
					isNeedUpdateVolumeConfirm = 1;
				}else{
					isNeedUpdateVolumeConfirm = 0;
				}
				if(icount < max_loop && isNeedUpdateVolumeConfirm ==1){
					rygel_media_player_set_volume (_tmp2_,expectvalue);
					icount++;
				}
				else{
					if(Remainder > 0 && isNeedUpdateVolumeConfirm ==1){
						if(isNeedUpdateVolume ==1){
							expectvalue = rygel_volume_from_percentage ((CurrentVolume+Remainder));
						}else if(isNeedUpdateVolume ==2){
							if(CurrentVolume >= Remainder){
								if(CurrentVolume - Remainder > 0)
									expectvalue = rygel_volume_from_percentage ((CurrentVolume-Remainder));
								else{
									if(Check_CurrentDesiredVolume == 0)
										expectvalue = 0.0;
									else if(Check_CurrentDesiredVolume > 0){
										expectvalue = rygel_volume_from_percentage (CurrentVolume);
									}
								}
							}else{
								if(Check_CurrentDesiredVolume == 0)
									expectvalue = 0.0;
								else if(Check_CurrentDesiredVolume > 0){
									expectvalue = rygel_volume_from_percentage (CurrentVolume);
								}
							}
						}
							rygel_media_player_set_volume (_tmp2_,expectvalue);
					}else{
					}
					isNeedUpdateVolume =0;
					isNeedUpdateVolumeConfirm = 0;
					vol_step = 0;
					icount=0;
					expectvalue=0.0;
					Remainder = 0;
					_tmp3_ = rygel_media_player_get_volume (_tmp2_);
					CurrentVolume = rygel_volume_to_percentage (_tmp3_);
					pthread_mutex_lock(&VolumeControlState);
					CurrentDesiredVolume = CurrentVolume;
					pthread_mutex_unlock(&VolumeControlState);
					Check_CurrentDesiredVolume = CurrentVolume;
					}
			}else{
				vol_step = 0;
				icount=0;
				expectvalue=0.0;
			}
			Last_CurrentDesiredVolume = Check_CurrentDesiredVolume;
		}else{
			//g_print("CurrentVolume=%d, Check_CurrentDesiredVolume=%d\n",CurrentVolume,Check_CurrentDesiredVolume);
			Last_CurrentDesiredVolume = CurrentVolume;
			if(LastCurrentVolume != CurrentVolume && vol_step ==0){
				rygel_rendering_control_set_volume_sync_hw (self, 0);
			}
			isNeedUpdateVolume =0;
			vol_step = 0;
			icount=0;
			expectvalue=0.0;
			Remainder = 0;
		}
		LastCurrentVolume = CurrentVolume;
		if(isNeedUpdateVolume ==0)
			sleepInterval = 980000;
		else
			sleepInterval = 600000;
			
		usleep(sleepInterval);	
	}
	//g_print("RygelVolumeControlThread Exit\n");
	
	return 0;
}

int StartThreadForVolumeControl(void *arg)
{
	int ret=0;
	RygelRenderingControl *self=(RygelRenderingControl*)arg;
	
		if(pthread_create(&RygelVolumeCtrl, NULL, &RygelVolumeControlThread, self) != 0) {
			fprintf(stderr, "%s:%s:Create RygelVolumeControlThread Thread Fail!\n", __FILE__, __FUNCTION__);
			ret=0;
		}else{
			//fprintf(stderr, "Create RygelVolumeControlThread OK\n");
			pthread_detach(RygelVolumeCtrl);
			ret=1;
		}
	return ret;
}

static void rygel_rendering_control_real_constructed (GObject* base) {
	double NowVolume=0.0;
	int err=0;
	RygelRenderingControl * self;
	RygelChangeLog* _tmp0_;
	RygelMediaPlayer* _tmp1_ = NULL;
	RygelMediaPlayer* _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	guint _tmp5_ = 0U;
	self = (RygelRenderingControl*) base;
	_tmp0_ = rygel_change_log_new ((GUPnPService*) self, RYGEL_RENDERING_CONTROL_LAST_CHANGE_NS);
	_g_object_unref0 (self->priv->changelog);
	self->priv->changelog = _tmp0_;
	_tmp1_ = rygel_rendering_control_get_player (self);
	_g_object_unref0 (self->priv->player);
	self->priv->player = _tmp1_;
	g_signal_connect_object ((GUPnPService*) self, "query-variable::LastChange", (GCallback) _rygel_rendering_control_query_last_change_cb_gupnp_service_query_variable, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::ListPresets", (GCallback) _rygel_rendering_control_list_presets_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::SelectPreset", (GCallback) _rygel_rendering_control_select_preset_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetMute", (GCallback) _rygel_rendering_control_get_mute_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::SetMute", (GCallback) _rygel_rendering_control_set_mute_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetVolume", (GCallback) _rygel_rendering_control_get_volume_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::SetVolume", (GCallback) _rygel_rendering_control_set_volume_cb_gupnp_service_action_invoked, self, 0);
	_tmp2_ = self->priv->player;
#if 1	
	_tmp3_ = rygel_media_player_get_volume (_tmp2_);
	_tmp5_ = rygel_volume_to_percentage (_tmp3_);
	self->priv->_volume = _tmp5_;
#else
	_tmp3_ = rygel_media_player_get_volume (_tmp2_);
#if (defined(CONFIG_RTL_8881A)||defined(CONFIG_RTL_8197F)) && defined(CONFIG_SND_RTL819XD_SOC_I2S)
	err = get_playback_mixer_control_wrapper("default", "DAC1", &NowVolume);
#elif defined(CONFIG_RTL_8196E) && defined(CONFIG_SND_USB_AUDIO)
		err = get_playback_mixer_control_wrapper("default", "Speaker", &NowVolume);
#else
		err = get_playback_mixer_control_wrapper("default","PCM", &NowVolume);		
#endif	
	if(err==0){
		//g_print("Current vol=%f\n",(NowVolume*100.0)/1024.0);
	}
	_tmp3_ = (NowVolume*100.0)/1024.0;
	_tmp4_ = _tmp3_/100.0;
	_tmp5_ = rygel_volume_to_percentage (_tmp4_);
	self->priv->_volume = _tmp5_;
	StartThreadForVolumeControl((void*)self);
#endif	
	
}


static void rygel_rendering_control_query_last_change_cb (RygelRenderingControl* self, GUPnPService* service, const gchar* variable, GValue* value) {
	RygelChangeLog* _tmp0_;
	RygelChangeLog* log;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_;
	gboolean _tmp3_;
	RygelChangeLog* _tmp4_;
	const gchar* _tmp5_;
	RygelChangeLog* _tmp6_;
	guint _tmp7_;
	guint _tmp8_;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	RygelChangeLog* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_;

	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (variable != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = rygel_change_log_new (NULL, RYGEL_RENDERING_CONTROL_LAST_CHANGE_NS);
	log = _tmp0_;
	_tmp2_ = rygel_rendering_control_get_mute (self);
	_tmp3_ = _tmp2_;
	if (_tmp3_) {
		_tmp1_ = "1";
	} else {
		_tmp1_ = "0";
	}
	_tmp4_ = log;
	_tmp5_ = _tmp1_;
	rygel_change_log_log_with_channel (_tmp4_, "Mute", _tmp5_, "Master");
	_tmp6_ = log;
	_tmp7_ = rygel_rendering_control_get_volume (self);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strdup_printf ("%u", _tmp8_);
	_tmp10_ = _tmp9_;
	rygel_change_log_log_with_channel (_tmp6_, "Volume", _tmp10_, "Master");
	_g_free0 (_tmp10_);

	_tmp14_ = self->priv->preset_name_list;
	//rygel_change_log_log_with_preset_list (log, "CurrentPresetNameList", _tmp14_);
	rygel_change_log_log_with_channel (log, "PresetNameList", _tmp14_, "Master");

	g_value_init (value, G_TYPE_STRING);
	_tmp11_ = log;
	_tmp12_ = rygel_change_log_finish (_tmp11_);
	_tmp13_ = _tmp12_;
	g_value_set_string (value, _tmp13_);
	_g_free0 (_tmp13_);
	_g_object_unref0 (log);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static RygelMediaPlayer* rygel_rendering_control_get_player (RygelRenderingControl* self) {
	RygelMediaPlayer* result = NULL;
	GUPnPRootDevice* _tmp0_ = NULL;
	GUPnPRootDevice* _tmp1_;
	GUPnPRootDevice* _tmp2_;
	GUPnPResourceFactory* _tmp3_;
	GUPnPResourceFactory* _tmp4_;
	RygelMediaRendererPlugin* _tmp5_;
	RygelMediaRendererPlugin* _tmp6_;
	RygelMediaRendererPlugin* plugin;
	RygelMediaPlayer* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp3_ = gupnp_device_info_get_resource_factory ((GUPnPDeviceInfo*) _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _g_object_ref0 (RYGEL_IS_MEDIA_RENDERER_PLUGIN (_tmp4_) ? ((RygelMediaRendererPlugin*) _tmp4_) : NULL);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp2_);
	plugin = _tmp6_;
	_tmp7_ = rygel_media_renderer_plugin_get_player (plugin);
	result = _tmp7_;
	_g_object_unref0 (plugin);
	return result;
}


static gboolean int64_try_parse (const gchar* str, gint64* _result_) {
	gint64 _vala_result = 0LL;
	gboolean result = FALSE;
	gchar* endptr = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gint64 _tmp2_ = 0LL;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	g_return_val_if_fail (str != NULL, FALSE);
	_tmp0_ = str;
	_tmp2_ = g_ascii_strtoll (_tmp0_, &_tmp1_, (guint) 0);
	endptr = _tmp1_;
	_vala_result = _tmp2_;
	_tmp3_ = endptr;
	_tmp4_ = str;
	_tmp5_ = str;
	_tmp6_ = strlen (_tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp3_ == (((gchar*) _tmp4_) + _tmp7_)) {
		result = TRUE;
		if (_result_) {
			*_result_ = _vala_result;
		}
		return result;
	} else {
		result = FALSE;
		if (_result_) {
			*_result_ = _vala_result;
		}
		return result;
	}
	if (_result_) {
		*_result_ = _vala_result;
	}
}


static gboolean rygel_rendering_control_check_instance_id (RygelRenderingControl* self, GUPnPServiceAction* action) {
	gboolean result = FALSE;
	gchar* instance_id_string = NULL;
	gint64 instance_id;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	gboolean _tmp6_;
	gint64 _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (action != NULL, FALSE);
	instance_id = (gint64) (-1);
	_tmp0_ = action;
	gupnp_service_action_get (_tmp0_, "InstanceID", G_TYPE_STRING, &instance_id_string, NULL);
	_tmp2_ = instance_id_string;
	if (_tmp2_ == NULL) {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp3_;
		gint64 _tmp4_ = 0LL;
		gboolean _tmp5_ = FALSE;
		_tmp3_ = instance_id_string;
		_tmp5_ = int64_try_parse (_tmp3_, &_tmp4_);
		instance_id = _tmp4_;
		_tmp1_ = !_tmp5_;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		GUPnPServiceAction* _tmp7_;
		const gchar* _tmp8_ = NULL;
		_tmp7_ = action;
		_tmp8_ = _ ("Invalid argument");
		gupnp_service_action_return_error (_tmp7_, (guint) 402, _tmp8_);
		result = FALSE;
		_g_free0 (instance_id_string);
		return result;
	}
	_tmp9_ = instance_id;
	if (_tmp9_ != ((gint64) 0)) {
		GUPnPServiceAction* _tmp10_;
		const gchar* _tmp11_ = NULL;
		_tmp10_ = action;
		_tmp11_ = _ ("Invalid InstanceID");
		gupnp_service_action_return_error (_tmp10_, (guint) 702, _tmp11_);
		result = FALSE;
		_g_free0 (instance_id_string);
		return result;
	}
	result = TRUE;
	_g_free0 (instance_id_string);
	return result;
}


static void rygel_rendering_control_list_presets_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	int MyRight=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	const gchar* _tmp3_;
	GUPnPServiceAction* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_rendering_control_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
	MyRight = CheckCurrentRight();
#else
	check = 1;
	MyRight = 1;
#endif			
	if (check==1 || MyRight==1) {
		_tmp2_ = action;
		_tmp3_ = self->priv->preset_name_list;
		gupnp_service_action_set (_tmp2_, "CurrentPresetNameList", G_TYPE_STRING, _tmp3_, NULL);
		_tmp4_ = action;
		gupnp_service_action_return (_tmp4_);
	} else {	
		const gchar* res = NULL;
		res = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, res);
	}
}


static void rygel_rendering_control_select_preset_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	int MyRight=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gchar* preset_name = NULL;
	GUPnPServiceAction* _tmp2_;
	const gchar* _tmp3_;
	GUPnPServiceAction* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_rendering_control_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
	MyRight = CheckCurrentRight();
#else
	check = 1;
	MyRight = 1;
#endif			
	if(check==0 || MyRight==0){
		const gchar* res = NULL;
		res = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, res);
		return;
	}
	_tmp2_ = action;
	gupnp_service_action_get (_tmp2_, "PresetName", G_TYPE_STRING, &preset_name, NULL);
	_tmp3_ = preset_name;
	if (g_strcmp0 (_tmp3_, "") != 0) {
		GUPnPServiceAction* _tmp4_;
		const gchar* _tmp5_ = NULL;
		_tmp4_ = action;
		_tmp5_ = _ ("Invalid Name");
		gupnp_service_action_return_error (_tmp4_, (guint) 701, _tmp5_);
		_g_free0 (preset_name);
		return;
	}
	_tmp6_ = action;
	gupnp_service_action_return (_tmp6_);
	_g_free0 (preset_name);
}


static gboolean rygel_rendering_control_check_channel (RygelRenderingControl* self, GUPnPServiceAction* action) {
	gboolean result = FALSE;
	gchar* channel = NULL;
	GUPnPServiceAction* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (action != NULL, FALSE);
	_tmp0_ = action;
	gupnp_service_action_get (_tmp0_, "Channel", G_TYPE_STRING, &channel, NULL);
	_tmp1_ = channel;
	if (g_strcmp0 (_tmp1_, "Master") != 0) {
		GUPnPServiceAction* _tmp2_;
		const gchar* _tmp3_ = NULL;
		_tmp2_ = action;
		_tmp3_ = _ ("Invalid Channel");
		gupnp_service_action_return_error (_tmp2_, (guint) 703, _tmp3_);
		result = FALSE;
		_g_free0 (channel);
		return result;
	}
	result = TRUE;
	_g_free0 (channel);
	return result;
}


static void rygel_rendering_control_get_mute_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	int MyRight=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	gboolean _tmp3_ = FALSE;
	GUPnPServiceAction* _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	GUPnPServiceAction* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_rendering_control_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_rendering_control_check_channel (self, _tmp2_);
	if (!_tmp3_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
	MyRight = CheckCurrentRight();
#else
	check = 1;
	MyRight =1;
#endif			
	_tmp4_ = action;
	_tmp5_ = rygel_rendering_control_get_mute (self);
	_tmp6_ = _tmp5_;
	if(check==1 && MyRight ==1){
		gupnp_service_action_set (_tmp4_, "CurrentMute", G_TYPE_BOOLEAN, _tmp6_, NULL);
	}else{
	_tmp6_ = FALSE;
		gupnp_service_action_set (_tmp4_, "CurrentMute", G_TYPE_BOOLEAN, _tmp6_, NULL);
	}
	_tmp7_ = action;
	gupnp_service_action_return (_tmp7_);
}


static void rygel_rendering_control_set_mute_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	int MyRight=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gchar* mute_str = NULL;
	GUPnPServiceAction* _tmp4_;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean mute = FALSE;
	GUPnPServiceAction* _tmp9_;
	gboolean _tmp10_;
	GUPnPServiceAction* _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_rendering_control_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
	MyRight = CheckCurrentRight();
#else
	check = 1;
	MyRight = 1;
#endif		
	if(check==0 || MyRight ==0){
		const gchar* res = NULL;
		res = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, res);
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_rendering_control_check_channel (self, _tmp2_);
	if (!_tmp3_) {
		return;
	}
	_tmp4_ = action;
	gupnp_service_action_get (_tmp4_, "DesiredMute", G_TYPE_STRING, &mute_str, NULL);
	_tmp5_ = mute_str;
	_tmp6_ = g_str_has_prefix (_tmp5_, "-");
	if (_tmp6_) {
		GUPnPServiceAction* _tmp7_;
		const gchar* _tmp8_ = NULL;
		_tmp7_ = action;
		_tmp8_ = _ ("Action Failed");
		gupnp_service_action_return_error (_tmp7_, (guint) 501, _tmp8_);
		_g_free0 (mute_str);
		return;
	}
	_tmp9_ = action;
	gupnp_service_action_get (_tmp9_, "DesiredMute", G_TYPE_BOOLEAN, &mute, NULL);
	_tmp10_ = mute;
	rygel_rendering_control_set_mute (self, _tmp10_);
	_tmp11_ = action;
	gupnp_service_action_return (_tmp11_);
	_g_free0 (mute_str);
}


static void rygel_rendering_control_get_volume_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	int MyRight=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	gboolean _tmp3_ = FALSE;
	GUPnPServiceAction* _tmp4_;
	guint _tmp5_;
	guint _tmp6_;
	GUPnPServiceAction* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_rendering_control_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_rendering_control_check_channel (self, _tmp2_);
	if (!_tmp3_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
	MyRight = CheckCurrentRight();
#else
	check = 1;
	MyRight = 1;
#endif			
	_tmp4_ = action;
	_tmp5_ = rygel_rendering_control_get_volume (self);
	_tmp6_ = _tmp5_;
	if(check==1 && MyRight==1){
		gupnp_service_action_set (_tmp4_, "CurrentVolume", G_TYPE_UINT, _tmp6_, NULL);
	}else{
		_tmp6_ = 0;
		gupnp_service_action_set (_tmp4_, "CurrentVolume", G_TYPE_UINT, _tmp6_, NULL);
	}
	_tmp7_ = action;
	gupnp_service_action_return (_tmp7_);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static void rygel_rendering_control_set_volume_cb (RygelRenderingControl* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	int MyRight=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gchar* volume_str = NULL;
	GUPnPServiceAction* _tmp4_;
	gboolean _tmp5_ = FALSE;
	const gchar* _tmp6_;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp10_;
	guint volume = 0U;
	GUPnPServiceAction* _tmp13_;
	guint _tmp14_;
	guint _tmp17_;
	GUPnPServiceAction* _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_rendering_control_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
	MyRight = CheckCurrentRight();
#else
	check = 1;
	MyRight = 1;
#endif			
	if(!(check==1 || MyRight ==1)){
		const gchar* res = NULL;
		res = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, res);
		return;
	}
	
	_tmp2_ = action;
	_tmp3_ = rygel_rendering_control_check_channel (self, _tmp2_);
	if (!_tmp3_) {
		return;
	}
	_tmp4_ = action;
	gupnp_service_action_get (_tmp4_, "DesiredVolume", G_TYPE_STRING, &volume_str, NULL);
	_tmp6_ = volume_str;
	_tmp7_ = string_contains (_tmp6_, ".");
	if (_tmp7_) {
		_tmp5_ = TRUE;
	} else {
		const gchar* _tmp8_;
		gboolean _tmp9_ = FALSE;
		_tmp8_ = volume_str;
		_tmp9_ = string_contains (_tmp8_, ",");
		_tmp5_ = _tmp9_;
	}
	_tmp10_ = _tmp5_;
	if (_tmp10_) {
		GUPnPServiceAction* _tmp11_;
		const gchar* _tmp12_ = NULL;
		_tmp11_ = action;
		_tmp12_ = _ ("Action Failed");
		gupnp_service_action_return_error (_tmp11_, (guint) 501, _tmp12_);
		_g_free0 (volume_str);
		return;
	}
	_tmp13_ = action;
	gupnp_service_action_get (_tmp13_, "DesiredVolume", G_TYPE_UINT, &volume, NULL);
	_tmp14_ = volume;
	if (_tmp14_ > ((guint) 100)) {
		GUPnPServiceAction* _tmp15_;
		const gchar* _tmp16_ = NULL;
		_tmp15_ = action;
		_tmp16_ = _ ("Action Failed");
		gupnp_service_action_return_error (_tmp15_, (guint) 501, _tmp16_);
		_g_free0 (volume_str);
		return;
	}
	_tmp17_ = volume;
	rygel_rendering_control_set_volume (self, _tmp17_);
	_tmp18_ = action;
	gupnp_service_action_return (_tmp18_);
	_g_free0 (volume_str);
}


RygelRenderingControl* rygel_rendering_control_construct (GType object_type) {
	RygelRenderingControl * self = NULL;
	self = (RygelRenderingControl*) g_object_new (object_type, NULL);
	return self;
}


RygelRenderingControl* rygel_rendering_control_new (void) {
	return rygel_rendering_control_construct (RYGEL_TYPE_RENDERING_CONTROL);
}


gboolean rygel_rendering_control_get_mute (RygelRenderingControl* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_mute;
	result = _tmp0_;
	return result;
}


void rygel_rendering_control_set_mute (RygelRenderingControl* self, gboolean value) {
	gboolean _tmp0_;
	gboolean _tmp1_;
	const gchar* _tmp7_ = NULL;
	gboolean _tmp8_;
	gboolean _tmp9_;
	RygelChangeLog* _tmp10_;
	const gchar* _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mute = _tmp0_;
	_tmp1_ = self->priv->_mute;
	if (_tmp1_) {
		RygelMediaPlayer* _tmp2_;
		_tmp2_ = self->priv->player;
		rygel_media_player_set_volume (_tmp2_, (gdouble) 0);
	} else {
		RygelMediaPlayer* _tmp3_;
		guint _tmp4_;
		guint _tmp5_;
		gdouble _tmp6_ = 0.0;
		_tmp3_ = self->priv->player;
		_tmp4_ = rygel_rendering_control_get_volume (self);
		_tmp5_ = _tmp4_;
		_tmp6_ = rygel_volume_from_percentage (_tmp5_);
		//rygel_media_player_set_volume (_tmp3_, _tmp6_);
		pthread_mutex_lock(&VolumeControlState);
		CurrentDesiredVolume = _tmp5_;
		pthread_mutex_unlock(&VolumeControlState);
		rygel_rendering_control_set_volume_sync_hw (self, _tmp5_);
		
	}
	_tmp8_ = rygel_rendering_control_get_mute (self);
	_tmp9_ = _tmp8_;
	if (_tmp9_) {
		_tmp7_ = "1";
	} else {
		_tmp7_ = "0";
	}
	_tmp10_ = self->priv->changelog;
	_tmp11_ = _tmp7_;
	rygel_change_log_log_with_channel (_tmp10_, "Mute", _tmp11_, "Master");
	g_object_notify ((GObject *) self, "mute");
}


guint rygel_rendering_control_get_volume (RygelRenderingControl* self) {
	guint result;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_volume;
	result = _tmp0_;
	return result;
}
void rygel_rendering_control_set_volume_sync_hw (RygelRenderingControl* self, guint value) {
	guint _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	RygelChangeLog* _tmp7_;
	guint _tmp8_;
	guint _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	g_return_if_fail (self != NULL);
		
	_tmp1_ = rygel_rendering_control_get_mute (self);
	_tmp2_ = _tmp1_;
	if (!_tmp2_) {
		_tmp0_ = value;
		self->priv->_volume = _tmp0_;
	}
	if (!_tmp2_) {
		RygelMediaPlayer* _tmp3_;
		guint _tmp4_;
		guint _tmp5_;
		gdouble _tmp6_ = 0.0;
		_tmp3_ = self->priv->player;
		_tmp4_ = rygel_rendering_control_get_volume (self);
		_tmp5_ = _tmp4_;
		_tmp6_ = rygel_volume_from_percentage (_tmp5_);
	}
	_tmp7_ = self->priv->changelog;
	_tmp8_ = rygel_rendering_control_get_volume (self);
	_tmp9_ = _tmp8_;
	if (_tmp2_) {
		_tmp9_ = 0;
	}
	_tmp10_ = g_strdup_printf ("%u", _tmp9_);
	_tmp11_ = _tmp10_;
	rygel_change_log_log_with_channel (_tmp7_, "Volume", _tmp11_, "Master");
	_g_free0 (_tmp11_);
	g_object_notify ((GObject *) self, "volume");
}


void rygel_rendering_control_set_volume (RygelRenderingControl* self, guint value) {
	guint _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	RygelChangeLog* _tmp7_;
	guint _tmp8_;
	guint _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_volume = _tmp0_;
	_tmp1_ = rygel_rendering_control_get_mute (self);
	_tmp2_ = _tmp1_;
	if (!_tmp2_) {
		RygelMediaPlayer* _tmp3_;
		guint _tmp4_;
		guint _tmp5_;
		gdouble _tmp6_ = 0.0;
		_tmp3_ = self->priv->player;
		_tmp4_ = rygel_rendering_control_get_volume (self);
		_tmp5_ = _tmp4_;
		_tmp6_ = rygel_volume_from_percentage (_tmp5_);
		rygel_media_player_set_volume (_tmp3_, _tmp6_);
		pthread_mutex_lock(&VolumeControlState);
		CurrentDesiredVolume = (_tmp5_*8)/10;
		pthread_mutex_unlock(&VolumeControlState);
		
	}
	_tmp7_ = self->priv->changelog;
	_tmp8_ = rygel_rendering_control_get_volume (self);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strdup_printf ("%u", _tmp9_);
	_tmp11_ = _tmp10_;
	rygel_change_log_log_with_channel (_tmp7_, "Volume", _tmp11_, "Master");
	_g_free0 (_tmp11_);
	g_object_notify ((GObject *) self, "volume");
}


static void rygel_rendering_control_class_init (RygelRenderingControlClass * klass) {
	rygel_rendering_control_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RygelRenderingControlPrivate));
	G_OBJECT_CLASS (klass)->constructed = rygel_rendering_control_real_constructed;
	G_OBJECT_CLASS (klass)->get_property = _vala_rygel_rendering_control_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_rygel_rendering_control_set_property;
	G_OBJECT_CLASS (klass)->finalize = rygel_rendering_control_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_RENDERING_CONTROL_MUTE, g_param_spec_boolean ("mute", "mute", "mute", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_RENDERING_CONTROL_VOLUME, g_param_spec_uint ("volume", "volume", "volume", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void rygel_rendering_control_instance_init (RygelRenderingControl * self) {
	gchar* _tmp0_;
	self->priv = RYGEL_RENDERING_CONTROL_GET_PRIVATE (self);
	self->priv->_mute = FALSE;
	self->priv->_volume = (guint) 0;
	_tmp0_ = g_strdup ("FactoryDefaults");
	self->priv->preset_name_list = _tmp0_;
	self_renderer_controler = self;
}


static void rygel_rendering_control_finalize (GObject* obj) {
	RygelRenderingControl * self;
	self = RYGEL_RENDERING_CONTROL (obj);
	_g_free0 (self->priv->preset_name_list);
	_g_object_unref0 (self->priv->changelog);
	_g_object_unref0 (self->priv->player);
	G_OBJECT_CLASS (rygel_rendering_control_parent_class)->finalize (obj);
	pthread_mutex_lock(&VolumeControlState);
	VolumeControlRunning =0;
	pthread_mutex_unlock(&VolumeControlState);
}


GType rygel_rendering_control_get_type (void) {
	static volatile gsize rygel_rendering_control_type_id__volatile = 0;
	if (g_once_init_enter (&rygel_rendering_control_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RygelRenderingControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_rendering_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelRenderingControl), 0, (GInstanceInitFunc) rygel_rendering_control_instance_init, NULL };
		GType rygel_rendering_control_type_id;
		rygel_rendering_control_type_id = g_type_register_static (GUPNP_TYPE_SERVICE, "RygelRenderingControl", &g_define_type_info, 0);
		g_once_init_leave (&rygel_rendering_control_type_id__volatile, rygel_rendering_control_type_id);
	}
	return rygel_rendering_control_type_id__volatile;
}


static void _vala_rygel_rendering_control_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RygelRenderingControl * self;
	self = RYGEL_RENDERING_CONTROL (object);
	switch (property_id) {
		case RYGEL_RENDERING_CONTROL_MUTE:
		g_value_set_boolean (value, rygel_rendering_control_get_mute (self));
		break;
		case RYGEL_RENDERING_CONTROL_VOLUME:
		g_value_set_uint (value, rygel_rendering_control_get_volume (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_rygel_rendering_control_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RygelRenderingControl * self;
	self = RYGEL_RENDERING_CONTROL (object);
	switch (property_id) {
		case RYGEL_RENDERING_CONTROL_MUTE:
		rygel_rendering_control_set_mute (self, g_value_get_boolean (value));
		break;
		case RYGEL_RENDERING_CONTROL_VOLUME:
		rygel_rendering_control_set_volume (self, g_value_get_uint (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



