/* rygel-av-transport.c generated by valac 0.16.1, the Vala compiler
 * generated from rygel-av-transport.vala, do not modify */

/*
 * Copyright (C) 2008 OpenedHand Ltd.
 * Copyright (C) 2009,2010 Nokia Corporation.
 * Copyright (C) 2012 Openismus GmbH.
 *
 * Author: Jorn Baayen <jorn@openedhand.com>
 *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
 *                               <zeeshan.ali@nokia.com>
 *         Jens Georg <jensg@openismus.com>
 *
 * Rygel is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Rygel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <libgupnp/gupnp.h>
#include <libsoup/soup.h>
#include <libgupnp-av/gupnp-av.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <gst/gst.h>
#include <float.h>
#include <math.h>
#include <rygel-core.h>
#include <glib/gi18n-lib.h>
#include <unistd.h>
#include "rygel-libpre.h"
#include "wfshm.h"
pthread_mutex_t GlobalControl=PTHREAD_MUTEX_INITIALIZER;
#define RYGEL_TYPE_AV_TRANSPORT (rygel_av_transport_get_type ())
#define RYGEL_AV_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_AV_TRANSPORT, RygelAVTransport))
#define RYGEL_AV_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_AV_TRANSPORT, RygelAVTransportClass))
#define RYGEL_IS_AV_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_AV_TRANSPORT))
#define RYGEL_IS_AV_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_AV_TRANSPORT))
#define RYGEL_AV_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_AV_TRANSPORT, RygelAVTransportClass))

typedef struct _RygelAVTransport RygelAVTransport;
typedef struct _RygelAVTransportClass RygelAVTransportClass;
typedef struct _RygelAVTransportPrivate RygelAVTransportPrivate;

#define RYGEL_TYPE_CHANGE_LOG (rygel_change_log_get_type ())
#define RYGEL_CHANGE_LOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CHANGE_LOG, RygelChangeLog))
#define RYGEL_CHANGE_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CHANGE_LOG, RygelChangeLogClass))
#define RYGEL_IS_CHANGE_LOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CHANGE_LOG))
#define RYGEL_IS_CHANGE_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CHANGE_LOG))
#define RYGEL_CHANGE_LOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CHANGE_LOG, RygelChangeLogClass))

typedef struct _RygelChangeLog RygelChangeLog;
typedef struct _RygelChangeLogClass RygelChangeLogClass;

#define RYGEL_TYPE_MEDIA_PLAYER (rygel_media_player_get_type ())
#define RYGEL_MEDIA_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_PLAYER, RygelMediaPlayer))
#define RYGEL_IS_MEDIA_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_PLAYER))
#define RYGEL_MEDIA_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_MEDIA_PLAYER, RygelMediaPlayerIface))

typedef struct _RygelMediaPlayer RygelMediaPlayer;
typedef struct _RygelMediaPlayerIface RygelMediaPlayerIface;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define RYGEL_TYPE_MEDIA_RENDERER_PLUGIN (rygel_media_renderer_plugin_get_type ())
#define RYGEL_MEDIA_RENDERER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN, RygelMediaRendererPlugin))
#define RYGEL_MEDIA_RENDERER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN, RygelMediaRendererPluginClass))
#define RYGEL_IS_MEDIA_RENDERER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN))
#define RYGEL_IS_MEDIA_RENDERER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN))
#define RYGEL_MEDIA_RENDERER_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_RENDERER_PLUGIN, RygelMediaRendererPluginClass))

typedef struct _RygelMediaRendererPlugin RygelMediaRendererPlugin;
typedef struct _RygelMediaRendererPluginClass RygelMediaRendererPluginClass;
typedef struct _Block1Data Block1Data;

struct _RygelAVTransport {
	GUPnPService parent_instance;
	RygelAVTransportPrivate * priv;
};

struct _RygelAVTransportClass {
	GUPnPServiceClass parent_class;
};

struct _RygelMediaPlayerIface {
	GTypeInterface parent_iface;
	gboolean (*seek) (RygelMediaPlayer* self, GstClockTime time);
	gchar** (*get_protocols) (RygelMediaPlayer* self, int* result_length1);
	gchar** (*get_mime_types) (RygelMediaPlayer* self, int* result_length1);
	gchar* (*get_playback_state) (RygelMediaPlayer* self);
	void (*set_playback_state) (RygelMediaPlayer* self, const gchar* value);
	gchar* (*get_uri) (RygelMediaPlayer* self);
	void (*set_uri) (RygelMediaPlayer* self, const gchar* value);
	gdouble (*get_volume) (RygelMediaPlayer* self);
	void (*set_volume) (RygelMediaPlayer* self, gdouble value);
	gint64 (*get_duration) (RygelMediaPlayer* self);
	gchar* (*get_metadata) (RygelMediaPlayer* self);
	void (*set_metadata) (RygelMediaPlayer* self, const gchar* value);
	gchar* (*get_mime_type) (RygelMediaPlayer* self);
	void (*set_mime_type) (RygelMediaPlayer* self, const gchar* value);
	gchar* (*get_content_features) (RygelMediaPlayer* self);
	void (*set_content_features) (RygelMediaPlayer* self, const gchar* value);
	gint64 (*get_position) (RygelMediaPlayer* self);
	gchar* (*get_current_transport_actions) (RygelMediaPlayer* self);
};

struct _RygelAVTransportPrivate {
	SoupSession* session;
	guint _n_tracks;
	guint _track;
	gchar* _metadata;
	gchar* _status;
	gchar* _speed;
	gchar* _mode;
	RygelChangeLog* changelog;
	RygelMediaPlayer* player;
};

struct _Block1Data {
	int _ref_count_;
	RygelAVTransport * self;
	gchar* _uri;
	gchar* _metadata;
	GUPnPServiceAction* action;
	gchar *_seek_target;
};


static gpointer rygel_av_transport_parent_class = NULL;

GType rygel_av_transport_get_type (void) G_GNUC_CONST;
GType rygel_change_log_get_type (void) G_GNUC_CONST;
GType rygel_media_player_get_type (void) G_GNUC_CONST;
#define RYGEL_AV_TRANSPORT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_AV_TRANSPORT, RygelAVTransportPrivate))
enum  {
	RYGEL_AV_TRANSPORT_DUMMY_PROPERTY,
	RYGEL_AV_TRANSPORT_N_TRACKS,
	RYGEL_AV_TRANSPORT_TRACK,
	RYGEL_AV_TRANSPORT_METADATA,
	RYGEL_AV_TRANSPORT_URI,
	RYGEL_AV_TRANSPORT_STATUS,
	RYGEL_AV_TRANSPORT_SPEED,
	RYGEL_AV_TRANSPORT_MODE
};
#define RYGEL_AV_TRANSPORT_UPNP_ID "urn:upnp-org:serviceId:AVTransport"
#define RYGEL_AV_TRANSPORT_UPNP_TYPE "urn:schemas-upnp-org:service:AVTransport:1"
#define RYGEL_AV_TRANSPORT_DESCRIPTION_PATH "xml/AVTransport2.xml"
#define RYGEL_AV_TRANSPORT_LAST_CHANGE_NS "urn:schemas-upnp-org:metadata-1-0/AVT/"
static void rygel_av_transport_real_constructed (GObject* base);
RygelChangeLog* rygel_change_log_new (GUPnPService* service, const gchar* service_ns);
RygelChangeLog* rygel_change_log_construct (GType object_type, GUPnPService* service, const gchar* service_ns);
static RygelMediaPlayer* rygel_av_transport_get_player (RygelAVTransport* self);
static void rygel_av_transport_query_last_change_cb (RygelAVTransport* self, GUPnPService* service, const gchar* variable, GValue* value);
static void _rygel_av_transport_query_last_change_cb_gupnp_service_query_variable (GUPnPService* _sender, const gchar* variable, GValue* value, gpointer self);
static void rygel_av_transport_set_av_transport_uri_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_set_av_transport_uri_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_get_media_info_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_get_media_info_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_get_media_info_ex_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_get_media_info_ex_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_get_transport_info_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_get_transport_info_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_get_position_info_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_get_position_info_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_get_device_capabilities_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_get_device_capabilities_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_get_transport_settings_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_get_transport_settings_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void _rygel_av_transport_get_transport_actions_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_stop_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_stop_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_play_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_play_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_pause_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_pause_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_seek_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_seek_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_next_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_next_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_previous_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
static void _rygel_av_transport_previous_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self);
static void rygel_av_transport_notify_state_cb (RygelAVTransport* self, GObject* player, GParamSpec* p);
static void _rygel_av_transport_notify_state_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void rygel_av_transport_notify_duration_cb (RygelAVTransport* self, GObject* player, GParamSpec* p);
static void _rygel_av_transport_notify_duration_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void rygel_av_transport_notify_uri_cb (RygelAVTransport* self, GObject* player, GParamSpec* p);
static void _rygel_av_transport_notify_uri_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void rygel_av_transport_notify_meta_data_cb (RygelAVTransport* self, GObject* player, GParamSpec* p);
static void _rygel_av_transport_notify_meta_data_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void rygel_av_transport_get_transport_actions_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action);
GType rygel_media_renderer_plugin_get_type (void) G_GNUC_CONST;
RygelMediaPlayer* rygel_media_renderer_plugin_get_player (RygelMediaRendererPlugin* self);
void rygel_change_log_log (RygelChangeLog* self, const gchar* variable, const gchar* value);
gchar* rygel_media_player_get_playback_state (RygelMediaPlayer* self);
const gchar* rygel_av_transport_get_status (RygelAVTransport* self);
const gchar* rygel_av_transport_get_mode (RygelAVTransport* self);
const gchar* rygel_av_transport_get_speed (RygelAVTransport* self);
guint rygel_av_transport_get_n_tracks (RygelAVTransport* self);
guint rygel_av_transport_get_track (RygelAVTransport* self);
gchar* rygel_media_player_get_duration_as_str (RygelMediaPlayer* self);
gint64 rygel_media_player_get_duration_as_time (RygelMediaPlayer* self);
gchar* rygel_av_transport_get_metadata (RygelAVTransport* self, gint double_escaped);
gchar* rygel_av_transport_get_uri (RygelAVTransport* self);
gchar* rygel_change_log_finish (RygelChangeLog* self);
static gboolean rygel_av_transport_check_instance_id (RygelAVTransport* self, GUPnPServiceAction* action);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
int GetMIMEType(Block1Data* Src_data1_, int Type, gchar *Dst);
int RetrieveProtocolInfofromMetadata(Block1Data* Src_data1_);
unsigned int RetrieveProtocolInfo_4th_OP_fromMetadata(Block1Data* Src_data1_);
unsigned long RetrieveDLNA_FLAGSfromMetadata(Block1Data* Src_data1_);
int CheckValidMetadata(Block1Data* Src_data1_);
static void ___lambda2_ (Block1Data* _data1_, SoupMessage* msg);
gchar** rygel_media_player_get_mime_types (RygelMediaPlayer* self, int* result_length1);
static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
void rygel_media_player_set_mime_type (RygelMediaPlayer* self, const gchar* value);
void rygel_media_player_set_content_features (RygelMediaPlayer* self, const gchar* value);
void rygel_av_transport_set_metadata (RygelAVTransport* self, const gchar* value);
void rygel_av_transport_set_uri (RygelAVTransport* self, const gchar* value);
void rygel_av_transport_set_n_tracks (RygelAVTransport* self, guint value);
static void ____lambda2__soup_message_finished (SoupMessage* _sender, gpointer self);
gchar* rygel_media_player_get_position_as_str (RygelMediaPlayer* self);
void rygel_media_player_set_playback_state (RygelMediaPlayer* self, const gchar* value);
gboolean rygel_media_player_seek (RygelMediaPlayer* self, GstClockTime time);
GstClockTime rygel_gst_utils_time_from_string (const gchar* str);
gchar* rygel_media_player_get_metadata (RygelMediaPlayer* self);
RygelAVTransport* rygel_av_transport_new (void);
RygelAVTransport* rygel_av_transport_construct (GType object_type);
void rygel_av_transport_set_track (RygelAVTransport* self, guint value);
void rygel_media_player_set_metadata (RygelMediaPlayer* self, const gchar* value);
gchar* rygel_media_player_get_uri (RygelMediaPlayer* self);
void rygel_media_player_set_uri (RygelMediaPlayer* self, const gchar* value);
void rygel_av_transport_set_status (RygelAVTransport* self, const gchar* value);
void rygel_av_transport_set_speed (RygelAVTransport* self, const gchar* value);
void rygel_av_transport_set_mode (RygelAVTransport* self, const gchar* value);
static void rygel_av_transport_finalize (GObject* obj);
static void _vala_rygel_av_transport_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_rygel_av_transport_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _rygel_av_transport_query_last_change_cb_gupnp_service_query_variable (GUPnPService* _sender, const gchar* variable, GValue* value, gpointer self) {
	rygel_av_transport_query_last_change_cb (self, _sender, variable, value);
}

static void _rygel_av_transport_set_av_transport_uri_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	
	rygel_av_transport_set_av_transport_uri_cb (self, _sender, action);
}


static void _rygel_av_transport_get_media_info_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_media_info_cb (self, _sender, action);
}


static void _rygel_av_transport_get_media_info_ex_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_media_info_ex_cb (self, _sender, action);
}


static void _rygel_av_transport_get_transport_info_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_transport_info_cb (self, _sender, action);
}


static void _rygel_av_transport_get_position_info_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_position_info_cb (self, _sender, action);
}


static void _rygel_av_transport_get_device_capabilities_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_device_capabilities_cb (self, _sender, action);
}


static void _rygel_av_transport_get_transport_settings_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_transport_settings_cb (self, _sender, action);
}

static void _rygel_av_transport_get_transport_actions_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_get_transport_actions_cb ((RygelAVTransport*) self, _sender, action);
}


static void _rygel_av_transport_stop_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_stop_cb (self, _sender, action);
}


static void _rygel_av_transport_play_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_play_cb (self, _sender, action);
}


static void _rygel_av_transport_pause_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_pause_cb (self, _sender, action);
}


static void _rygel_av_transport_seek_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_seek_cb (self, _sender, action);
}


static void _rygel_av_transport_next_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_next_cb (self, _sender, action);
}


static void _rygel_av_transport_previous_cb_gupnp_service_action_invoked (GUPnPService* _sender, GUPnPServiceAction* action, gpointer self) {
	rygel_av_transport_previous_cb (self, _sender, action);
}


static void _rygel_av_transport_notify_state_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	rygel_av_transport_notify_state_cb (self, _sender, pspec);
}


static void _rygel_av_transport_notify_duration_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	rygel_av_transport_notify_duration_cb (self, _sender, pspec);
}


static void _rygel_av_transport_notify_uri_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	rygel_av_transport_notify_uri_cb (self, _sender, pspec);
}


static void _rygel_av_transport_notify_meta_data_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	rygel_av_transport_notify_meta_data_cb (self, _sender, pspec);
}


static void rygel_av_transport_real_constructed (GObject* base) {
	RygelAVTransport * self;
	RygelChangeLog* _tmp0_;
	RygelMediaPlayer* _tmp1_ = NULL;
	RygelMediaPlayer* _tmp2_;
	RygelMediaPlayer* _tmp3_;
	RygelMediaPlayer* _tmp4_;
	RygelMediaPlayer* _tmp5_;
	SoupSessionAsync* _tmp6_;
	self = (RygelAVTransport*) base;
	_tmp0_ = rygel_change_log_new ((GUPnPService*) self, RYGEL_AV_TRANSPORT_LAST_CHANGE_NS);
	_g_object_unref0 (self->priv->changelog);
	self->priv->changelog = _tmp0_;
	_tmp1_ = rygel_av_transport_get_player (self);
	_g_object_unref0 (self->priv->player);
	self->priv->player = _tmp1_;
	g_signal_connect_object ((GUPnPService*) self, "query-variable::LastChange", (GCallback) _rygel_av_transport_query_last_change_cb_gupnp_service_query_variable, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::SetAVTransportURI", (GCallback) _rygel_av_transport_set_av_transport_uri_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetMediaInfo", (GCallback) _rygel_av_transport_get_media_info_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetMediaInfo_Ext", (GCallback) _rygel_av_transport_get_media_info_ex_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetTransportInfo", (GCallback) _rygel_av_transport_get_transport_info_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetPositionInfo", (GCallback) _rygel_av_transport_get_position_info_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetDeviceCapabilities", (GCallback) _rygel_av_transport_get_device_capabilities_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetTransportSettings", (GCallback) _rygel_av_transport_get_transport_settings_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetCurrentTransportActions", (GCallback) _rygel_av_transport_get_transport_actions_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Stop", (GCallback) _rygel_av_transport_stop_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Play", (GCallback) _rygel_av_transport_play_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Pause", (GCallback) _rygel_av_transport_pause_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Seek", (GCallback) _rygel_av_transport_seek_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Next", (GCallback) _rygel_av_transport_next_cb_gupnp_service_action_invoked, self, 0);
	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Previous", (GCallback) _rygel_av_transport_previous_cb_gupnp_service_action_invoked, self, 0);
	_tmp2_ = self->priv->player;
	g_signal_connect_object ((GObject*) _tmp2_, "notify::playback-state", (GCallback) _rygel_av_transport_notify_state_cb_g_object_notify, self, 0);
	_tmp3_ = self->priv->player;
	g_signal_connect_object ((GObject*) _tmp3_, "notify::duration", (GCallback) _rygel_av_transport_notify_duration_cb_g_object_notify, self, 0);
	_tmp4_ = self->priv->player;
	g_signal_connect_object ((GObject*) _tmp4_, "notify::uri", (GCallback) _rygel_av_transport_notify_uri_cb_g_object_notify, self, 0);
	_tmp5_ = self->priv->player;
	g_signal_connect_object ((GObject*) _tmp5_, "notify::metadata", (GCallback) _rygel_av_transport_notify_meta_data_cb_g_object_notify, self, 0);
	_tmp6_ = (SoupSessionAsync*) soup_session_async_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = (SoupSession*) _tmp6_;
#if defined(CONFIG_RTL_PRE_EMPTIVE)	
	initCurrentOwner();
#endif
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static RygelMediaPlayer* rygel_av_transport_get_player (RygelAVTransport* self) {
	RygelMediaPlayer* result = NULL;
	GUPnPRootDevice* _tmp0_ = NULL;
	GUPnPRootDevice* _tmp1_;
	GUPnPRootDevice* _tmp2_;
	GUPnPResourceFactory* _tmp3_;
	GUPnPResourceFactory* _tmp4_;
	RygelMediaRendererPlugin* _tmp5_;
	RygelMediaRendererPlugin* _tmp6_;
	RygelMediaRendererPlugin* plugin;
	RygelMediaPlayer* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp3_ = gupnp_device_info_get_resource_factory ((GUPnPDeviceInfo*) _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _g_object_ref0 (RYGEL_IS_MEDIA_RENDERER_PLUGIN (_tmp4_) ? ((RygelMediaRendererPlugin*) _tmp4_) : NULL);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp2_);
	plugin = _tmp6_;
	_tmp7_ = rygel_media_renderer_plugin_get_player (plugin);
	result = _tmp7_;
	_g_object_unref0 (plugin);
	return result;
}


static void rygel_av_transport_query_last_change_cb (RygelAVTransport* self, GUPnPService* service, const gchar* variable, GValue* value) {
	RygelChangeLog* _tmp0_;
	RygelChangeLog* log;
	RygelMediaPlayer* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	guint _tmp11_;
	guint _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	guint _tmp15_;
	guint _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_;
	RygelMediaPlayer* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	RygelMediaPlayer* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_;
	gchar* _tmp26_;
	gchar* _tmp27_;
	gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* _tmp35_;
	gchar* _tmp36_;
	gchar* _tmp37_;
	gchar* _tmp38_;
	gchar* _tmp39_ = NULL;
	gchar* _tmp40_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (variable != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = rygel_change_log_new (NULL, RYGEL_AV_TRANSPORT_LAST_CHANGE_NS);
	log = _tmp0_;
	_tmp1_ = self->priv->player;
	_tmp2_ = rygel_media_player_get_playback_state (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;
	rygel_change_log_log (log, "TransportState", _tmp4_);
	_g_free0 (_tmp4_);
	_tmp1_ = self->priv->player;
	_tmp5_ = rygel_player_controller_get_current_transport_actions (_tmp1_);
	_tmp6_ = _tmp5_;
	_tmp7_ = _tmp6_;
	rygel_change_log_log (log, "CurrentTransportActions", _tmp7_);
	_g_free0 (_tmp7_);
	
	
	
	_tmp5_ = rygel_av_transport_get_status (self);
	_tmp6_ = _tmp5_;
	rygel_change_log_log (log, "TransportStatus", _tmp6_);
	rygel_change_log_log (log, "PlaybackStorageMedium", "NOT_IMPLEMENTED");
	rygel_change_log_log (log, "RecordStorageMedium", "NOT_IMPLEMENTED");
	rygel_change_log_log (log, "PossiblePlaybackStorageMedia", "NOT_IMPLEMENTED");
	rygel_change_log_log (log, "PossibleRecordStorageMedia", "NOT_IMPLEMENTED");
	_tmp7_ = rygel_av_transport_get_mode (self);
	_tmp8_ = _tmp7_;
	rygel_change_log_log (log, "CurrentPlayMode", _tmp8_);
	_tmp9_ = rygel_av_transport_get_speed (self);
	_tmp10_ = _tmp9_;
	rygel_change_log_log (log, "TransportPlaySpeed", _tmp10_);
	rygel_change_log_log (log, "RecordMediumWriteStatus", "NOT_IMPLEMENTED");
	rygel_change_log_log (log, "CurrentRecordQualityMode", "NOT_IMPLEMENTED");
	rygel_change_log_log (log, "PossibleRecordQualityMode", "NOT_IMPLEMENTED");
	_tmp11_ = rygel_av_transport_get_n_tracks (self);
	_tmp12_ = _tmp11_;
	_tmp13_ = g_strdup_printf ("%u", _tmp12_);
	_tmp14_ = _tmp13_;
	rygel_change_log_log (log, "NumberOfTracks", _tmp14_);
	_g_free0 (_tmp14_);
	_tmp15_ = rygel_av_transport_get_track (self);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strdup_printf ("%u", _tmp16_);
	_tmp18_ = _tmp17_;
	rygel_change_log_log (log, "CurrentTrack", _tmp18_);
	_g_free0 (_tmp18_);
	_tmp19_ = self->priv->player;
	_tmp20_ = rygel_media_player_get_duration_as_str (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = _tmp21_;
	rygel_change_log_log (log, "CurrentTrackDuration", _tmp22_);
	_g_free0 (_tmp22_);
	_tmp23_ = self->priv->player;
	_tmp24_ = rygel_media_player_get_duration_as_str (_tmp23_);
	_tmp25_ = _tmp24_;
	_tmp26_ = _tmp25_;
	rygel_change_log_log (log, "CurrentMediaDuration", _tmp26_);
	_g_free0 (_tmp26_);
	_tmp27_ = rygel_av_transport_get_metadata (self,1);
	_tmp28_ = _tmp27_;
	_tmp29_ = _tmp28_;
	rygel_change_log_log (log, "CurrentTrackMetaData", _tmp29_);
	_g_free0 (_tmp29_);
	_tmp30_ = rygel_av_transport_get_metadata (self,1);
	_tmp31_ = _tmp30_;
	_tmp32_ = _tmp31_;
	rygel_change_log_log (log, "AVTransportURIMetaData", _tmp32_);
	_g_free0 (_tmp32_);
	_tmp33_ = rygel_av_transport_get_uri (self);
	_tmp34_ = _tmp33_;
	_tmp35_ = _tmp34_;
	rygel_change_log_log (log, "CurrentTrackURI", _tmp35_);
	_g_free0 (_tmp35_);
	_tmp36_ = rygel_av_transport_get_uri (self);
	_tmp37_ = _tmp36_;
	_tmp38_ = _tmp37_;
	rygel_change_log_log (log, "AVTransportURI", _tmp38_);
	_g_free0 (_tmp38_);
	rygel_change_log_log (log, "NextAVTransportURI", "NOT_IMPLEMENTED");
	rygel_change_log_log (log, "NextAVTransportURIMetaData", "NOT_IMPLEMENTED");
	g_value_init (value, G_TYPE_STRING);
	_tmp39_ = rygel_change_log_finish (log);
	_tmp40_ = _tmp39_;
	g_value_set_string (value, _tmp40_);
	_g_free0 (_tmp40_);
	_g_object_unref0 (log);
}


static gboolean int64_try_parse (const gchar* str, gint64* _result_) {
	gint64 _vala_result = 0LL;
	gboolean result = FALSE;
	gchar* endptr = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gint64 _tmp2_ = 0LL;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	g_return_val_if_fail (str != NULL, FALSE);
	_tmp0_ = str;
	_tmp2_ = g_ascii_strtoll (_tmp0_, &_tmp1_, (guint) 0);
	endptr = _tmp1_;
	_vala_result = _tmp2_;
	_tmp3_ = endptr;
	_tmp4_ = str;
	_tmp5_ = str;
	_tmp6_ = strlen (_tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp3_ == (((gchar*) _tmp4_) + _tmp7_)) {
		result = TRUE;
		if (_result_) {
			*_result_ = _vala_result;
		}
		return result;
	} else {
		result = FALSE;
		if (_result_) {
			*_result_ = _vala_result;
		}
		return result;
	}
	if (_result_) {
		*_result_ = _vala_result;
	}
}


static gboolean rygel_av_transport_check_instance_id (RygelAVTransport* self, GUPnPServiceAction* action) {
	gboolean result = FALSE;
	gchar* instance_id_string = NULL;
	gint64 instance_id;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	gboolean _tmp6_;
	gint64 _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (action != NULL, FALSE);
	instance_id = (gint64) (-1);
	_tmp0_ = action;
	gupnp_service_action_get (_tmp0_, "InstanceID", G_TYPE_STRING, &instance_id_string, NULL);
	_tmp2_ = instance_id_string;
	if (_tmp2_ == NULL) {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp3_;
		gint64 _tmp4_ = 0LL;
		gboolean _tmp5_ = FALSE;
		_tmp3_ = instance_id_string;
		_tmp5_ = int64_try_parse (_tmp3_, &_tmp4_);
		instance_id = _tmp4_;
		_tmp1_ = !_tmp5_;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		GUPnPServiceAction* _tmp7_;
		const gchar* _tmp8_ = NULL;
		_tmp7_ = action;
		_tmp8_ = _ ("Invalid argument");
		gupnp_service_action_return_error (_tmp7_, (guint) 402, _tmp8_);
		result = FALSE;
		_g_free0 (instance_id_string);
		return result;
	}
	_tmp9_ = instance_id;
	if (_tmp9_ != ((gint64) 0)) {
		GUPnPServiceAction* _tmp10_;
		const gchar* _tmp11_ = NULL;
		_tmp10_ = action;
		_tmp11_ = _ ("Invalid InstanceID");
		gupnp_service_action_return_error (_tmp10_, (guint) 718, _tmp11_);
		result = FALSE;
		_g_free0 (instance_id_string);
		return result;
	}
	result = TRUE;
	_g_free0 (instance_id_string);
	return result;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		RygelAVTransport * self;
		self = _data1_->self;
		_g_free0 (_data1_->_metadata);
		_g_free0 (_data1_->_uri);
		_g_free0 (_data1_->_seek_target);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}
static void ___lambda2_seek (Block1Data* _data1_, SoupMessage* msg) {

	RygelAVTransport * self;
	SoupMessage* _tmp0_;
	guint _tmp1_ = 0U;
	guint _tmp2_;
	const gchar* _tmp9_;
	const gchar* ret_action;
	const gchar* _tmp00_Seek=NULL;
	gchar seek_range_start[64];
	gchar seek_range_end[64];
	GstClockTime _tmp10_start = 0ULL;
	GstClockTime _tmp10_end = 0ULL;
	char *Strtk=NULL;
	char *Strtk1=NULL;
	GstClockTime _tmp10_ = 0ULL;
	gboolean _tmp11_ = FALSE;
	GUPnPServiceAction* _tmp34_;
	const char *value;
	self = _data1_->self;
	g_return_if_fail (msg != NULL);
	_tmp0_ = msg;
	g_object_get (_tmp0_, "status-code", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != ((guint) SOUP_STATUS_OK)) {
		const gchar* _tmp3_;
		SoupMessage* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar* _tmp7_;
		GUPnPServiceAction* _tmp8_;
		if (_tmp2_ == ((guint) SOUP_STATUS_BAD_REQUEST)) { //donot recognize http HEAD for contentfeature
			g_message("%s %d SOUP_STATUS_BAD_REQUEST", __FUNCTION__, __LINE__);
		}
		_tmp3_ = _data1_->_uri;
		_tmp4_ = msg;
		g_object_get (_tmp4_, "reason-phrase", &_tmp5_, NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = _tmp6_;
		g_message ("%s %d Failed to access %s: %s", __FUNCTION__, __LINE__, _tmp3_, _tmp7_);
		_g_free0 (_tmp7_);
		_tmp8_ = _data1_->action;
		gupnp_service_action_return_error (_tmp8_, (guint) 716, "Resource not found");
		return;
	} else
	 {
		if ((value = soup_message_headers_get_one (msg->response_headers,"availableSeekRange.dlna.org")) != NULL) { 
   		 	//g_message("%s %d available seek range:%s, target:%s", __FUNCTION__, __LINE__, value,_data1_->_seek_target);
    		}
		_tmp00_Seek = rygel_media_player_get_seek_mode_by_op_param(self->priv->player);
		if (!strcmp(_tmp00_Seek, "10") ){
			Strtk = strstr(value, "npt=");
				if(Strtk != NULL){
					Strtk1 = strstr(Strtk, "-");
					snprintf(seek_range_start, (Strtk1-Strtk -strlen("npt=")+1), "%s", Strtk+strlen("npt="));
					//g_message("%s %d Range start:%s", __FUNCTION__, __LINE__, seek_range_start);
					snprintf(seek_range_end, (strlen(Strtk1)-1+1), "%s", Strtk1+1);
					//g_message("%s %d Range end:%s", __FUNCTION__, __LINE__, seek_range_end);
					_tmp10_start = rygel_gst_utils_time_from_string (seek_range_start);
					_tmp10_end = rygel_gst_utils_time_from_string (seek_range_end);
					_tmp10_ = rygel_gst_utils_time_from_string (_data1_->_seek_target);
					if (_tmp10_ < _tmp10_start || _tmp10_ > _tmp10_end) {
						ret_action = _ ("Illegal Seek Target");
						gupnp_service_action_return_error (_data1_->action, (guint) 711, ret_action);
						_g_free0(_tmp00_Seek);
						return;
					}
				}
		}
		_g_free0(_tmp00_Seek);
		_tmp10_ = rygel_gst_utils_time_from_string (_data1_->_seek_target);
		_tmp11_ = rygel_media_player_seek (self->priv->player, _tmp10_);
		if (!_tmp11_) {
			GUPnPServiceAction* _tmp12_;
			const gchar* _tmp13_ = NULL;
			_tmp12_ = _data1_->action;
			_tmp13_ = _ ("Seek mode not supported");
			gupnp_service_action_return_error (_tmp12_, (guint) 710, _tmp13_);
			return;
		}


		_tmp34_ = _data1_->action;
		gupnp_service_action_return (_tmp34_);
	}
}



static void ___lambda2_ (Block1Data* _data1_, SoupMessage* msg) {
	gchar MimeType[64];
	gchar dlnafeatures[128];
	int retrievefromMetadata=0;
	int isFoundfeatures=0;
	int isFoundmime=0;
	RygelAVTransport * self;
	SoupMessage* _tmp0_;
	gchar* mime=NULL;
	guint _tmp1_ = 0U;
	guint _tmp2_;
	
	SoupMessage* _tmp9_;
	SoupMessageHeaders* _tmp10_;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	gboolean _tmp13_ = FALSE;
	const gchar* _tmp14_;
	gboolean _tmp20_;
	GUPnPServiceAction* _tmp21_;
	RygelMediaPlayer* _tmp22_;
	const gchar* _tmp23_;
	SoupMessage* _tmp24_;
	SoupMessageHeaders* _tmp25_;
	const gchar* _tmp26_ = NULL;
	gchar* _tmp27_;
	gchar* features;
	const gchar* _tmp28_;
	const gchar* _tmp32_;
	const gchar* _tmp33_;
	GUPnPServiceAction* _tmp34_;
	gchar* NowState=NULL;
	self = _data1_->self;
	g_return_if_fail (msg != NULL);
	_tmp0_ = msg;
	g_object_get (_tmp0_, "status-code", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != ((guint) SOUP_STATUS_OK)) {
		const gchar* _tmp3_;
		SoupMessage* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar* _tmp7_;
		GUPnPServiceAction* _tmp8_;
		if (_tmp2_ == ((guint) SOUP_STATUS_BAD_REQUEST)) { //donot recognize http HEAD for contentfeature
			if(_data1_ -> _metadata != NULL){
				g_warning("%s, %d:metadata=%s", __FUNCTION__, __LINE__, _data1_ -> _metadata);
			}else{
				g_warning("%s, %d:metadata is NULL", __FUNCTION__, __LINE__);
			}
			
			if(_data1_ -> _metadata != NULL && GetMIMEType(_data1_, 1, &dlnafeatures) == 1){
					isFoundfeatures = 1;
			}
			if(_data1_ -> _metadata != NULL && GetMIMEType(_data1_, 0, &MimeType) == 1){
				isFoundmime = 1;
				mime = g_strdup (&MimeType);
			}
			if(isFoundfeatures == 1 || isFoundmime == 1){
				retrievefromMetadata = 1;
				goto InAdvance;
			}
		}
		_tmp3_ = _data1_->_uri;
		_tmp4_ = msg;
		g_object_get (_tmp4_, "reason-phrase", &_tmp5_, NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = _tmp6_;
		g_warning ("rygel-av-transport.vala:250: Failed to access %s: %s", _tmp3_, _tmp7_);
		_g_free0 (_tmp7_);
		_tmp8_ = _data1_->action;
		gupnp_service_action_return_error (_tmp8_, (guint) 716, "Resource not found");
		return;
	} else {
		   
		_tmp9_ = msg;
		_tmp10_ = _tmp9_->response_headers;
		_tmp11_ = soup_message_headers_get_one (_tmp10_, "Content-Type");
		_tmp12_ = g_strdup (_tmp11_);
		mime = _tmp12_;
		_tmp14_ = mime;
		if (_tmp14_ != NULL) {
			const gchar* _tmp15_;
			RygelMediaPlayer* _tmp16_;
			gint _tmp17_ = 0;
			gchar** _tmp18_ = NULL;
			gchar** _tmp19_;
			gint _tmp19__length1;
			_tmp15_ = mime;
			_tmp16_ = self->priv->player;
			_tmp18_ = rygel_media_player_get_mime_types (_tmp16_, &_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp19__length1 = _tmp17_;
			_tmp13_ = !_vala_string_array_contains (_tmp19_, _tmp17_, _tmp15_);
			_tmp19_ = (_vala_array_free (_tmp19_, _tmp19__length1, (GDestroyNotify) g_free), NULL);
		} else {
			_tmp13_ = FALSE;
		}
		_tmp20_ = _tmp13_;
		if (_tmp20_) {
			
			_tmp21_ = _data1_->action;
			if(_data1_ -> _metadata != NULL && GetMIMEType(_data1_, 0, &MimeType) == 1){
				_g_free0 (mime);
				mime = g_strdup (&MimeType);
			}else{
				gupnp_service_action_return_error (_tmp21_, (guint) 714, "Illegal MIME-type");
				g_warning("%s, %d:Illegal MIME-type", __FUNCTION__, __LINE__);
				_g_free0 (mime);
				return;
			}
		}
InAdvance:		
		if(retrievefromMetadata == 0){
			_tmp22_ = self->priv->player;
			_tmp23_ = mime;
			rygel_media_player_set_mime_type (_tmp22_, _tmp23_);
			_tmp24_ = msg;
			_tmp25_ = _tmp24_->response_headers;
			_tmp26_ = soup_message_headers_get_one (_tmp25_, "contentFeatures.dlna.org");
			_tmp27_ = g_strdup (_tmp26_);
			features = _tmp27_;
			_tmp28_ = features;
			if (_tmp28_ != NULL) {
				RygelMediaPlayer* _tmp29_;
				const gchar* _tmp30_;
				_tmp29_ = self->priv->player;
				_tmp30_ = features;
				rygel_media_player_set_content_features (_tmp29_, _tmp30_);
			} else {
				RygelMediaPlayer* _tmp31_;
				_tmp31_ = self->priv->player;
				rygel_media_player_set_content_features (_tmp31_, "*");
			}
		
		}else{
			
			if(isFoundmime == 0){
				if(mime != NULL){
					_g_free0 (mime);
				}
				gupnp_service_action_return_error (_tmp21_, (guint) 714, "Illegal MIME-type");
				g_warning("%s, %d:Illegal MIME-type", __FUNCTION__, __LINE__);
				return;
			}else{
				_tmp22_ = self->priv->player;
				_tmp23_ = mime;
				rygel_media_player_set_mime_type (_tmp22_, _tmp23_);
			}
			
			if(isFoundfeatures == 1){
				_tmp22_ = self->priv->player;
				features = g_strdup (&dlnafeatures);
				rygel_media_player_set_content_features (_tmp22_, features);
			}else{
				_tmp22_ = self->priv->player;
				rygel_media_player_set_content_features (_tmp22_, "*");
			}
			
		}
#if defined(CONFIG_RTL_PRE_EMPTIVE)
		Update_CurrentServedData((void*)self->priv->changelog,_data1_->action);
		NowState = rygel_media_player_get_playback_state (self->priv->player);
		if (strcmp(NowState, "STOPPED")) {
			rygel_media_player_set_playback_state (self->priv->player, "STOPPED");
		}
		_g_free0 (NowState);
#endif		
		_tmp32_ = _data1_->_metadata;
		rygel_av_transport_set_metadata (self, _tmp32_);
		_tmp33_ = _data1_->_uri;
		rygel_av_transport_set_uri (self, _tmp33_);
		rygel_av_transport_set_n_tracks (self, (guint) 1);
		rygel_av_transport_set_track (self, (guint) 1);
		_tmp34_ = _data1_->action;
		gupnp_service_action_return (_tmp34_);
		_g_free0 (features);
		_g_free0 (mime);
	}
}


static void ____lambda2__soup_message_finished (SoupMessage* _sender, gpointer self) {
	___lambda2_ (self, _sender);
}
static void ____lambda2_seek_soup_message_finished (SoupMessage* _sender, gpointer self) {
	___lambda2_seek (self, _sender);
}

int GetMIMEType(Block1Data* Src_data1_, int Type, gchar *Dst)
{
	RygelAVTransport * self=Src_data1_->self;
	RygelMediaPlayer*  selfPlayer=self->priv->player;
	gchar* features;
	char *token=NULL, *savestr1=NULL;
	char buff[2048]={0};
	char buff1[2048]={0};
	char buff2[2048]={0};
	char buffBitrate[128]={0};
	char buffSize[128]={0};
	char buffDuration[128]={0};
	char *Strtk=NULL;
	char *Strtk1=NULL;
	char *Strtk2=NULL;
	char *Strtk3=NULL;
	char *Strtk4=NULL;
	char buff3[2048]={0};
	char *token1=NULL,*savestr2=NULL;

	int index=0;
	int found_bitrate=0;
	int found_size=0;
	int found_duration=0;
	int found_mime=0;
	int found_features=0;
	int ret=0;
	long ContentSize=0;
//protocolInfo="http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01700000000000000000000000000000" 
//bitrate="320" size="10361560" duration="00:04:18">
	//bitrate="320" size="9887455" duration="00:03:59"
	Strtk = strstr(Src_data1_->_metadata, "protocolInfo=");
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, ">");
		if(Strtk1 != NULL){
			snprintf(buff1, Strtk1-(Strtk+strlen("protocolInfo="))+1, "%s", Strtk+strlen("protocolInfo="));
			//g_warning("buffer1=%s", buff1);
			//for protocolInfo 
			Strtk2 = strstr(buff1, "\"");
			if(Strtk2 != NULL){
				Strtk3 = strstr(Strtk2+1, "\"");
				if(Strtk3 != NULL){
					snprintf(buff, Strtk3-Strtk2,"%s", Strtk2+1);
					//g_warning("protocolInfo=%s", buff);
					ret = 1;
				}else
					ret=0;
			}else
				ret=0;
				
		if(ret ==1 ){			
			token=NULL;
			savestr1=NULL;	     
			sprintf(buff2, "%s", buff);	
			token = strtok_r(buff2,":", &savestr1);
			do{
			if (token == NULL){
				ret=0;
				break;
			}else{  
				if(index ==2){
					const gchar* _tmp15_;
					gboolean _tmp13_ = FALSE;
					gchar* mime=token;
					gint _tmp17_ = 0;
					gchar** _tmp18_ = NULL;
					gchar** _tmp19_;
					gint _tmp19__length1;
					//g_warning("MIME-Type:%s", token);
					sprintf(buff3, "%s", token);
					if (strstr(buff3,";")) {
						token1=strtok_r(buff3,";", &savestr2);
						if (token1!=NULL)
							mime = token1;
					}

					_tmp15_ = mime;
					_tmp18_ = rygel_media_player_get_mime_types (selfPlayer, &_tmp17_);
					_tmp19_ = _tmp18_;
					_tmp19__length1 = _tmp17_;
					_tmp13_ = !_vala_string_array_contains (_tmp19_, _tmp17_, _tmp15_);
					_tmp19_ = (_vala_array_free (_tmp19_, _tmp19__length1, (GDestroyNotify) g_free), NULL);
					if(!_tmp13_){
						found_mime = 1;
						if(Type == 0)
							sprintf(Dst, "%s", mime);
					}else{
						 g_warning("%s, %d, Illegal MIME-type %s", __FUNCTION__, __LINE__,token);
						 ret= 0;
					}
				}
				if(index ==3){
					if(Type == 1)
						g_warning("dlnafeatures:%s", token);
					features = token;
					
					if(strstr(token, "DLNA.ORG_")){
						if(Type == 1)
							sprintf(Dst, "%s", features);
						found_features=1;
					}else{
					}
				}
			}
			token = strtok_r(NULL, ": ", &savestr1);
			index++;
			}while(token !=NULL);		
		}		
		//for bitrate
		Strtk2 = strstr(buff1, "bitrate=");
		if(Strtk2 != NULL){
			Strtk3 = strstr(Strtk2+strlen("bitrate=")+1, "\"");
			if(Strtk3 != NULL){
				snprintf(buffBitrate, Strtk3-(Strtk2+strlen("bitrate=")),"%s", Strtk2+strlen("bitrate=")+1);
				//g_warning("bitrate=%s", buffBitrate);
				found_bitrate = 1;
			}else
				ret=0;
		}else
			found_bitrate = 0;
		//for size
		Strtk2 = strstr(buff1, "size=");
		if(Strtk2 != NULL){
			Strtk3 = strstr(Strtk2+strlen("size=")+1, "\"");
			if(Strtk3 != NULL){
				snprintf(buffSize, Strtk3-(Strtk2+strlen("size=")),"%s", Strtk2+strlen("size=")+1);
				//g_warning("size=%s", buffSize);
				found_size = 1;
			}else
				ret=0;
		}else
			found_size = 0;
			
		if(found_size) {
			ContentSize = strtol(buffSize, NULL, 0);
			if(ContentSize > 0)
				found_size = 1;
			else
				found_size = 0;
		}
			
		//for duration
		Strtk2 = strstr(buff1, "duration=");
		if(Strtk2 != NULL){
			Strtk3 = strstr(Strtk2+strlen("duration=")+1, "\"");
			if(Strtk3 != NULL){
				snprintf(buffDuration, Strtk3-(Strtk2+strlen("duration=")),"%s", Strtk2+strlen("duration=")+1);
				//g_warning("duration=%s", buffDuration);
				found_duration = 1;
			}else
				ret=0;
		}else
			found_duration = 0;
			
		if(found_duration){
			if(strcmp(buffDuration, "0:00:00") && strcmp(buffDuration, "00:00:00") && strcmp(buffDuration, "0:00:00.000") && strcmp(buffDuration, "00:00:00.000")){
				ret = 1;
			}else{
				found_duration = 0;
			}
		}	
	}else
		ret=0;
	
	if(found_mime == 1 &&(found_size == 1 ||found_duration == 1 || found_features ==1)){
		ret =1;
	}else 
		ret = 0;
	}
	return ret;
}


int RetrieveProtocolInfofromMetadata(Block1Data* Src_data1_)
{
	char buff[2048]={0};
	char buff1[2048]={0};
	char *Strtk=NULL;
	char *Strtk1=NULL;
	char *Strtk2=NULL;
	char *Strtk3=NULL;

	int ret=0;
//protocolInfo="http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01700000000000000000000000000000" 
	Strtk = strstr(Src_data1_->_metadata, "protocolInfo=");
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, ">");
		if(Strtk1 != NULL){
			snprintf(buff1, Strtk1-(Strtk+strlen("protocolInfo="))+1, "%s", Strtk+strlen("protocolInfo="));
			//g_warning("buffer1=%s", buff1);
			//for protocolInfo 
			Strtk2 = strstr(buff1, "\"");
			if(Strtk2 != NULL){
				Strtk3 = strstr(Strtk2+1, "\"");
				if(Strtk3 != NULL){
					snprintf(buff, Strtk3-Strtk2,"%s", Strtk2+1);
					//g_debug("protocolInfo=%s", buff);
					ret = 1;
				}else
					ret=0;
			}else
				ret=0;
		}
	}		
		if(ret ==1 ){
			UpdateCurrentConnectionProtocolInfo(buff);
		}else {
			//g_message("%s %d protocolInfo=%s", __FUNCTION__, __LINE__, "NULL");
			UpdateCurrentConnectionProtocolInfo(NULL);
		}		
	return ret;
}

unsigned long RetrieveDLNA_FLAGSfromMetadata(Block1Data* Src_data1_)
{
	char buff[2048]={0};
	char buff1[2048]={0};
	char buff2[2048]={0};
	char *Strtk=NULL;
	char *Strtk1=NULL;
	char *Strtk2=NULL;
	char *Strtk3=NULL;
	unsigned long dlna_glags=0;
	int ret=0;
//protocolInfo="http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01700000000000000000000000000000" 
	Strtk = strstr(Src_data1_->_metadata, "protocolInfo=");
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, ">");
		if(Strtk1 != NULL){
			snprintf(buff1, Strtk1-(Strtk+strlen("protocolInfo="))+1, "%s", Strtk+strlen("protocolInfo="));
			//g_warning("buffer1=%s", buff1);
			//for protocolInfo 
			Strtk2 = strstr(buff1, "\"");
			if(Strtk2 != NULL){
				Strtk3 = strstr(Strtk2+1, "\"");
				if(Strtk3 != NULL){
					snprintf(buff, Strtk3-Strtk2,"%s", Strtk2+1);
					//g_message("%s %d protocolInfo=%s", __FUNCTION__, __LINE__, buff);
					ret = 1;
				}else
					ret=0;
			}else
				ret=0;
		}
	}		
		if(ret ==1 ){
			Strtk = strstr(buff, "DLNA.ORG_FLAGS=");
			if(Strtk != NULL){
				snprintf(buff2, 8+1, "%s", Strtk+strlen("DLNA.ORG_FLAGS="));
				dlna_glags = strtoul (buff2, NULL, 16);
//				g_message("%s %d DLNA.ORG_FLAGS=%s", __FUNCTION__, __LINE__, buff2);
			}
		}	
	return dlna_glags;
}



unsigned int RetrieveProtocolInfo_4th_OP_fromMetadata(Block1Data* Src_data1_)
{
	unsigned long dlna_glags=0;
	char buff[2048]={0};
	char buff1[2048]={0};
	char buff2[2048]={0};
	char buff3[2048]={0};

	char *Strtk=NULL;
	char *Strtk1=NULL;
	char *Strtk2=NULL;
	char *Strtk3=NULL;

	unsigned int ret=0;
//protocolInfo="http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01700000000000000000000000000000" 
	Strtk = strstr(Src_data1_->_metadata, "protocolInfo=");
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, ">");
		if(Strtk1 != NULL){
			snprintf(buff1, Strtk1-(Strtk+strlen("protocolInfo="))+1, "%s", Strtk+strlen("protocolInfo="));
			//g_warning("buffer1=%s", buff1);
			//for protocolInfo 
			Strtk2 = strstr(buff1, "\"");
			if(Strtk2 != NULL){
				Strtk3 = strstr(Strtk2+1, "\"");
				if(Strtk3 != NULL){
					snprintf(buff, Strtk3-Strtk2,"%s", Strtk2+1);
					//g_message("%s %d protocolInfo=%s", __FUNCTION__, __LINE__, buff);
					ret = 1;
				}else
					ret=0;
			}else
				ret=0;
		}
	}
	if (ret ==1) {
		//Retrieve op-param
		Strtk = strstr(buff, "DLNA.ORG_OP=");
		if(Strtk != NULL){
			Strtk1 = strstr(Strtk, ";");
			if(Strtk1 != NULL){
				snprintf(buff2, Strtk1-(Strtk+strlen("DLNA.ORG_OP="))+1, "%s", Strtk+strlen("DLNA.ORG_OP="));
				//g_message("%s %d op-maram:%s",__FUNCTION__, __LINE__, buff2);
				if (!strcmp(buff2, "10"))
					ret=2;
				else if (!strcmp(buff2, "01"))
					ret=1;
				else if (!strcmp(buff2, "11"))
					ret=2;
			}else {
				snprintf(buff2, 2+1, "%s", Strtk+strlen("DLNA.ORG_OP="));
				//g_message("%s %d op-maram:%s",__FUNCTION__, __LINE__, buff2);
				if (!strcmp(buff2, "10"))
					ret=2;
				else if (!strcmp(buff2, "01"))
					ret=1;
				else if (!strcmp(buff2, "11"))
					ret=2;
			}
		}else{
			#if 0
			Strtk = strstr(buff, "DLNA.ORG_FLAGS=");
			if(Strtk != NULL){
				snprintf(buff3, 8+1, "%s", Strtk+strlen("DLNA.ORG_FLAGS="));
				dlna_glags = strtoul (buff3, NULL, 16);
				ret=0;
				//g_message("%s %d flags-maram:%s, Hex:%08X",__FUNCTION__, __LINE__, buff3, dlna_glags);
				if ( (dlna_glags & GUPNP_DLNA_FLAGS_TIME_BASED_SEEK) == GUPNP_DLNA_FLAGS_TIME_BASED_SEEK) {
					ret= 2;
				}
				if ((dlna_glags & GUPNP_DLNA_FLAGS_BYTE_BASED_SEEK) == GUPNP_DLNA_FLAGS_BYTE_BASED_SEEK) {
					if (ret > 0) {
						ret = ret | 0x1;
					}else
						ret =1;
				}
				
			}else {
				ret = 0;
				g_message("%s %d No op-param found!",__FUNCTION__, __LINE__);
			}
			#endif
			ret = 0;
			g_debug("%s %d No op-param found!",__FUNCTION__, __LINE__);
		}
	}else {
		ret = 0;
		g_debug("%s %d No op-param found!",__FUNCTION__, __LINE__);
	}	
	return ret;
}




//Example of Metadata
/*
<DIDL-Lite xmlns="urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/" 
xmlns:dc="http://purl.org/dc/elements/1.1/" 
xmlns:upnp="urn:schemas-upnp-org:metadata-1-0/upnp/">
<item id="8ac9237d-2282-4294-8109-02d97488308f" parentID="3" restricted="111111">
<dc:title>B-LPCM-1 - xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</dc:title>
<upnp:class>object.item.audioItem</upnp:class>
<upnp:albumArtURI>http://192.168.3.101:50421/0/3/1/8ac9237d-2282-4294-8109-02d97488308f/a715d0f9-a6bf-4d29-b4ed-b039cae6dd8d////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////      </upnp:albumArtURI>
<upnp:channelNr>999999999999999999999      </upnp:channelNr>
<res protocolInfo="http-get:*:audio/L16;rate=44100;channels=1:DLNA.ORG_PN=LPCM;DLNA.ORG_OP=01"  size="5303806"  duration="00:01:00"  importUri="http://192.168.3.101:50421/0/3/1/8ac9237d-2282-4294-8109-02d97488308f" >http://192.168.3.101:50421/0/3/1/8ac9237d-2282-4294-8109-02d97488308f/a715d0f9-a6bf-4d29-b4ed-b039cae6dd8d</res>
</item>
</DIDL-Lite>

*/



int CheckValidMetadata(Block1Data* Src_data1_)
{
	
	
	char buff[2048]={0};
	char buff1[2048]={0};
	char *Strtk=NULL;
	char *Strtk1=NULL;
	char *Strtk2=NULL;
	char *Strtk3=NULL;
	char *Strtk4=NULL;
	guint year;
	guint month;
	guint date;
	
	
	guint hour = 0;
	guint min = 0;
	guint sec = 0;
	
	int dc_date_valid=1;
	int res_duration_valid=1;
	int dc_title_valid=1;
	int restricted_valid=1;
	int channelNr_valid=1;
	int ret=0;
	Strtk = strstr(Src_data1_->_metadata, "dc:title");
	
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, "<");
		if(Strtk1 != NULL){
			snprintf(buff1, (Strtk1-Strtk-strlen("dc:title")-1+1), "%s", Strtk+strlen("dc:title")+1);
			
			if (strlen(buff1) > 256)
				dc_title_valid = 0;
			else
				dc_title_valid = 1;
		}
	}
	memset(buff1, 0x00, 2048);
	memset(buff, 0x00, 2048);
	Strtk = strstr(Src_data1_->_metadata, "restricted=");
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, ">");
		if(Strtk1 != NULL){
			snprintf(buff1, Strtk1-Strtk-strlen("restricted=")-2+1, "%s", Strtk+strlen("restricted=")+1);
			
			if (strlen(buff1) > 1)
				restricted_valid = 0;
			else
				restricted_valid = 1;
		}
				
	}
	memset(buff1, 0x00, 2048);
	memset(buff, 0x00, 2048);
	Strtk = strstr(Src_data1_->_metadata, "channelNr");
	
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, "<");
		if(Strtk1 != NULL){
			snprintf(buff1, (Strtk1-Strtk-strlen("channelNr")-1+1), "%s", Strtk+strlen("channelNr")+1);
			
			if (strlen(buff1) > 1)
				channelNr_valid = 0;
			else
				channelNr_valid = 1;
		}
	}
	memset(buff1, 0x00, 2048);
	memset(buff, 0x00, 2048);
	Strtk = strstr(Src_data1_->_metadata, "dc:date");
	
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, "<");
		if(Strtk1 != NULL){
			snprintf(buff1, (Strtk1-Strtk-strlen("dc:date")-1+1), "%s", Strtk+strlen("dc:date")+1);
			Strtk1 = strstr(buff1, "-");
			sscanf(buff1, "%u-%u-%u", &year, &month, &date);
			if (((Strtk1-buff1) > 4 )|| month >12 || date > 31)
				dc_date_valid = 0;
			else
				dc_date_valid = 1;
		}
	}
	memset(buff1, 0x00, 2048);
	memset(buff, 0x00, 2048);
	Strtk = strstr(Src_data1_->_metadata, "duration=");
	if(Strtk != NULL){
		Strtk1 = strstr(Strtk, ">");
		if(Strtk1 != NULL){
			snprintf(buff1, Strtk1-(Strtk+strlen("duration="))+1, "%s", Strtk+strlen("duration="));
			
			
			Strtk2 = strstr(buff1, "\"");
			if(Strtk2 != NULL){
				Strtk3 = strstr(Strtk2+1, "\"");
				if(Strtk3 != NULL){
					snprintf(buff, Strtk3-Strtk2,"%s", Strtk2+1);
					Strtk4 = strstr(buff, ":");
					sscanf(buff, "%u:%u:%u", &hour, &min, &sec);
					if (((Strtk4-buff)> 3) || min > 59 || sec > 59)
						res_duration_valid = 0;
					else
						res_duration_valid = 1;
				}
			}
		}
	}	
	
	if (dc_title_valid ==0 || restricted_valid==0 || channelNr_valid ==0 || dc_date_valid==0 || res_duration_valid ==0) {
		g_debug("%d %d %d %d %d", dc_title_valid, restricted_valid, channelNr_valid, dc_date_valid, res_duration_valid);
		g_debug("\nmetadata is INVALID!=>%s\n",Src_data1_->_metadata);
		ret=0;
	}else
		ret=1;
	return ret;
}


static void rygel_av_transport_set_av_transport_uri_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int CheckMetadata=1;
	unsigned int CurrentSeekMode=0;
	unsigned int CurrentSeekMode_OP=0;
	unsigned long CurrentDLNA_FLAGS=0;
	GUPnPServiceAction* _tmp221_;
	Block1Data* _data1_;
	GUPnPServiceAction* _tmp0_;
	GUPnPServiceAction* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GUPnPServiceAction* _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = action;
	_data1_->action = _tmp0_;
	_tmp1_ = _data1_->action;
	_tmp2_ = rygel_av_transport_check_instance_id (self, _tmp1_);
	if (!_tmp2_) {
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return;
	}
	_tmp3_ = _data1_->action;
	gupnp_service_action_get (_tmp3_, "CurrentURI", G_TYPE_STRING, &_data1_->_uri, "CurrentURIMetaData", G_TYPE_STRING, &_data1_->_metadata, NULL);
	//g_warning("CurrentURIMeteData=%s",_data1_->_metadata);
	_tmp5_ = _data1_->_uri;
	_tmp6_ = g_str_has_prefix (_tmp5_, "http://");
	if (_tmp6_) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp7_;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = _data1_->_uri;
		_tmp8_ = g_str_has_prefix (_tmp7_, "https://");
		_tmp4_ = _tmp8_;
	}
	_tmp9_ = _tmp4_;
	if (_data1_->_metadata != NULL) {
		RetrieveProtocolInfofromMetadata(_data1_);
		CurrentDLNA_FLAGS = RetrieveDLNA_FLAGSfromMetadata(_data1_);
		rygel_media_player_set_player_dlna_flags (self->priv->player, (guint)CurrentDLNA_FLAGS);
		CurrentSeekMode_OP = RetrieveProtocolInfo_4th_OP_fromMetadata(_data1_);
		if (CurrentSeekMode_OP == 0) {
			 rygel_media_player_set_seek_mode_by_op_param (self->priv->player, "00");
		} else if (CurrentSeekMode_OP == 1) {
			rygel_media_player_set_seek_mode_by_op_param (self->priv->player, "01");
		}else if (CurrentSeekMode_OP == 2) {
			rygel_media_player_set_seek_mode_by_op_param (self->priv->player, "10");
		}
		
		CurrentSeekMode = 0;
		if ( (CurrentDLNA_FLAGS & GUPNP_DLNA_FLAGS_TIME_BASED_SEEK) == GUPNP_DLNA_FLAGS_TIME_BASED_SEEK) {
			CurrentSeekMode= 2;
		}
		if ((CurrentDLNA_FLAGS & GUPNP_DLNA_FLAGS_BYTE_BASED_SEEK) == GUPNP_DLNA_FLAGS_BYTE_BASED_SEEK) {
			if (CurrentSeekMode > 0) {
				CurrentSeekMode = CurrentSeekMode | 0x1;
			}else
				CurrentSeekMode =1;
		}
		
		if (CurrentSeekMode == 0) { //check OP in advance
			rygel_media_player_set_renderer_seek_mode(self->priv->player,CurrentSeekMode_OP);
		}else {
			//if (CurrentSeekMode ==3)
			//	rygel_media_player_set_renderer_seek_mode(self->priv->player,2);
			//else
				rygel_media_player_set_renderer_seek_mode(self->priv->player,CurrentSeekMode);
		}
	
		
		CheckMetadata = CheckValidMetadata(_data1_);
		if (CheckMetadata == 0) {
			const gchar* _tmp01_ = NULL;
			_tmp221_ = _data1_->action;
			_tmp01_ = _ ("Invalid Args");
			gupnp_service_action_return_error (_tmp221_, (guint) 402, _tmp01_);
			rygel_media_player_set_metadata(self->priv->player, "");
			rygel_media_player_set_uri (self->priv->player, "");
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return;
		}
	}
	if (_tmp9_) {
		const gchar* _tmp10_;
		SoupMessage* _tmp11_;
		SoupMessage* message;
		SoupMessage* _tmp12_;
		SoupMessageHeaders* _tmp13_;
		SoupMessage* _tmp14_;
		SoupSession* _tmp15_;
		SoupMessage* _tmp16_;
		SoupMessage* _tmp17_;
		_tmp10_ = _data1_->_uri;
		_tmp11_ = soup_message_new ("HEAD", _tmp10_);
		message = _tmp11_;
		_tmp12_ = message;
		_tmp13_ = _tmp12_->request_headers;
		soup_message_headers_append (_tmp13_, "getContentFeatures.dlna.org", "1");
		soup_message_headers_append (_tmp13_, "Connection", "close");
		_tmp14_ = message;
		g_signal_connect_data (_tmp14_, "finished", (GCallback) ____lambda2__soup_message_finished, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
		_tmp15_ = self->priv->session;
		_tmp16_ = message;
		_tmp17_ = _g_object_ref0 (_tmp16_);
		soup_session_queue_message (_tmp15_, _tmp17_, NULL, NULL);
		_g_object_unref0 (message);
	} else {
		const gchar* _tmp18_;
		const gchar* _tmp19_;
		const gchar* _tmp20_;
		GUPnPServiceAction* _tmp21_;
		_tmp18_ = _data1_->_metadata;
		rygel_av_transport_set_metadata (self, _tmp18_);
		_tmp19_ = _data1_->_uri;
		rygel_av_transport_set_uri (self, _tmp19_);
		_tmp20_ = _data1_->_uri;
		if (g_strcmp0 (_tmp20_, "") == 0) {
			rygel_av_transport_set_n_tracks (self, (guint) 0);
			rygel_av_transport_set_track (self, (guint) 0);
		} else {
			rygel_av_transport_set_n_tracks (self, (guint) 1);
			rygel_av_transport_set_track (self, (guint) 1);
		}
		_tmp21_ = _data1_->action;
		gupnp_service_action_return (_tmp21_);
	}
	
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static void rygel_av_transport_get_media_info_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	RygelMediaPlayer* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GUPnPServiceAction* _tmp15_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_av_transport_get_n_tracks (self);
	_tmp4_ = _tmp3_;
	_tmp5_ = self->priv->player;
	_tmp6_ = rygel_media_player_get_duration_as_str (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = _tmp7_;
	_tmp9_ = rygel_av_transport_get_uri (self);
	_tmp10_ = _tmp9_;
	_tmp11_ = _tmp10_;
	_tmp12_ = rygel_av_transport_get_metadata (self,0);
	_tmp13_ = _tmp12_;
	_tmp14_ = _tmp13_;
	gupnp_service_action_set (_tmp2_, "NrTracks", G_TYPE_UINT, _tmp4_, "MediaDuration", G_TYPE_STRING, _tmp8_, "CurrentURI", G_TYPE_STRING, _tmp11_, "CurrentURIMetaData", G_TYPE_STRING, _tmp14_, "NextURI", G_TYPE_STRING, "NOT_IMPLEMENTED", "NextURIMetaData", G_TYPE_STRING, "NOT_IMPLEMENTED", "PlayMedium", G_TYPE_STRING, "NOT_IMPLEMENTED", "RecordMedium", G_TYPE_STRING, "NOT_IMPLEMENTED", "WriteStatus", G_TYPE_STRING, "NOT_IMPLEMENTED", NULL);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp8_);
	_tmp15_ = action;
	gupnp_service_action_return (_tmp15_);
}


static void rygel_av_transport_get_media_info_ex_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	RygelMediaPlayer* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GUPnPServiceAction* _tmp15_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_av_transport_get_n_tracks (self);
	_tmp4_ = _tmp3_;
	_tmp5_ = self->priv->player;
	_tmp6_ = rygel_media_player_get_duration_as_str (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = _tmp7_;
	_tmp9_ = rygel_av_transport_get_uri (self);
	_tmp10_ = _tmp9_;
	_tmp11_ = _tmp10_;
	_tmp12_ = rygel_av_transport_get_metadata (self,0);
	_tmp13_ = _tmp12_;
	_tmp14_ = _tmp13_;
	gupnp_service_action_set (_tmp2_, "CurrentType", G_TYPE_STRING, "NO_MEDIA", "NrTracks", G_TYPE_UINT, _tmp4_, "MediaDuration", G_TYPE_STRING, _tmp8_, "CurrentURI", G_TYPE_STRING, _tmp11_, "CurrentURIMetaData", G_TYPE_STRING, _tmp14_, "NextURI", G_TYPE_STRING, "NOT_IMPLEMENTED", "NextURIMetaData", G_TYPE_STRING, "NOT_IMPLEMENTED", "PlayMedium", G_TYPE_STRING, "NOT_IMPLEMENTED", "RecordMedium", G_TYPE_STRING, "NOT_IMPLEMENTED", "WriteStatus", G_TYPE_STRING, "NOT_IMPLEMENTED", NULL);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp8_);
	_tmp15_ = action;
	gupnp_service_action_return (_tmp15_);
}


static void rygel_av_transport_get_transport_info_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	RygelMediaPlayer* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	GUPnPServiceAction* _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = self->priv->player;
	_tmp4_ = rygel_media_player_get_playback_state (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	_tmp7_ = rygel_av_transport_get_status (self);
	_tmp8_ = _tmp7_;
	_tmp9_ = rygel_av_transport_get_speed (self);
	_tmp10_ = _tmp9_;
#if defined(CONFIG_RTL_PRE_EMPTIVE)	
	check = isCurrentServedClient(action);
#else
	check = 1;
#endif	
	if(check == 1){
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
		if(CheckCurrentRight()==0){
			if( (action->client_UserAgent == PORTABLE))
				{
					GUPnPServiceAction* _tmp00_;
					const gchar* _tmp01_ = NULL;
					_tmp00_ = action;
					_tmp01_ = _ ("Invalid Action");
					gupnp_service_action_return_error (_tmp00_, (guint) 401, _tmp01_);
				_g_free0 (_tmp6_);
				return;
				
			}else{
			gupnp_service_action_set (_tmp2_, "CurrentTransportState", G_TYPE_STRING, "STOPPED", "CurrentTransportStatus", G_TYPE_STRING, _tmp8_, "CurrentSpeed", G_TYPE_STRING, _tmp10_, NULL);
			}
		}else
#endif			
			gupnp_service_action_set (_tmp2_, "CurrentTransportState", G_TYPE_STRING, _tmp6_, "CurrentTransportStatus", G_TYPE_STRING, _tmp8_, "CurrentSpeed", G_TYPE_STRING, _tmp10_, NULL);
	}else{
		gupnp_service_action_set (_tmp2_, "CurrentTransportState", G_TYPE_STRING, "STOPPED", "CurrentTransportStatus", G_TYPE_STRING, _tmp8_, "CurrentSpeed", G_TYPE_STRING, _tmp10_, NULL);
	}
	
	_g_free0 (_tmp6_);
	_tmp11_ = action;
	gupnp_service_action_return (_tmp11_);
}

static void rygel_av_transport_get_transport_actions_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_ = NULL;
	RygelMediaPlayer* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	GUPnPServiceAction* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = self->priv->player;
	_tmp4_ = rygel_player_controller_get_current_transport_actions (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	gupnp_service_action_set (_tmp2_, "Actions", G_TYPE_STRING, _tmp6_, NULL);
	_g_free0 (_tmp6_);
	_tmp7_ = action;
	gupnp_service_action_return (_tmp7_);
}


static void rygel_av_transport_get_position_info_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	RygelMediaPlayer* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	RygelMediaPlayer* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	RygelMediaPlayer* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* gstState;
	gint _tmp23_;
	gint _tmp24_;
	GUPnPServiceAction* _tmp25_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_av_transport_get_track (self);
	_tmp4_ = _tmp3_;
	_tmp5_ = self->priv->player;
	_tmp6_ = rygel_media_player_get_duration_as_str (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = _tmp7_;
	_tmp9_ = rygel_av_transport_get_metadata (self,0);
	_tmp10_ = _tmp9_;
	_tmp11_ = _tmp10_;
	_tmp12_ = rygel_av_transport_get_uri (self);
	_tmp13_ = _tmp12_;
	_tmp14_ = _tmp13_;
	_tmp15_ = self->priv->player;
	_tmp16_ = rygel_media_player_get_position_as_str (_tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = _tmp17_;
	_tmp19_ = self->priv->player;
	_tmp20_ = rygel_media_player_get_position_as_str (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = _tmp21_;
	_tmp23_ = G_MAXINT;
	_tmp24_ = G_MAXINT;

#if defined(CONFIG_RTL_PRE_EMPTIVE)	
	check = isCurrentServedClient(action);
#else
	check = 1;
#endif	
		if(check==1){
			#if defined(CONFIG_RTL_PRE_EMPTIVE)		
			if(CheckCurrentRight()==0){
					if( (action->client_UserAgent == PORTABLE))
					{
						GUPnPServiceAction* _tmp00_;
						const gchar* _tmp01_ = NULL;
						_tmp00_ = action;
						_tmp01_ = _ ("Invalid Action");
						gupnp_service_action_return_error (_tmp00_, (guint) 401, _tmp01_);
					_g_free0 (_tmp22_);
					_g_free0 (_tmp18_);
					_g_free0 (_tmp14_);
					_g_free0 (_tmp11_);
					_g_free0 (_tmp8_);
					return;
					
				}else{
						_tmp4_ = 0;
						gupnp_service_action_set (_tmp2_, "Track", G_TYPE_UINT, _tmp4_, "TrackDuration", G_TYPE_STRING, "0:00:00", "TrackMetaData", G_TYPE_STRING, "", "TrackURI", G_TYPE_STRING, "", "RelTime", G_TYPE_STRING, "0:00:00", "AbsTime", G_TYPE_STRING, "0:00:00", "RelCount", G_TYPE_INT, _tmp23_, "AbsCount", G_TYPE_INT, _tmp24_, NULL);
					}
				}else
		#endif		
				{	
					gupnp_service_action_set (_tmp2_, "Track", G_TYPE_UINT, _tmp4_, "TrackDuration", G_TYPE_STRING, _tmp8_, "TrackMetaData", G_TYPE_STRING, _tmp11_, "TrackURI", G_TYPE_STRING, _tmp14_, "RelTime", G_TYPE_STRING, _tmp18_, "AbsTime", G_TYPE_STRING, _tmp22_, "RelCount", G_TYPE_INT, _tmp23_, "AbsCount", G_TYPE_INT, _tmp24_, NULL);
				}
		}else{
			_tmp4_ = 0;
			_tmp23_= 0;
			_tmp24_ = 0;
			gupnp_service_action_set (_tmp2_, "Track", G_TYPE_UINT, _tmp4_, "TrackDuration", G_TYPE_STRING, "0:00:00", "TrackMetaData", G_TYPE_STRING, "", "TrackURI", G_TYPE_STRING, "", "RelTime", G_TYPE_STRING, "0:00:00", "AbsTime", G_TYPE_STRING, "0:00:00", "RelCount", G_TYPE_INT, _tmp23_, "AbsCount", G_TYPE_INT, _tmp24_, NULL);
		}

	_g_free0 (_tmp22_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp8_);
	_tmp25_ = action;
	gupnp_service_action_return (_tmp25_);
}


static void rygel_av_transport_get_device_capabilities_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	GUPnPServiceAction* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	gupnp_service_action_set (_tmp2_, "PlayMedia", G_TYPE_STRING, "None,Network", "RecMedia", G_TYPE_STRING, "NOT_IMPLEMENTED", "RecQualityModes", G_TYPE_STRING, "NOT_IMPLEMENTED", NULL);
	_tmp3_ = action;
	gupnp_service_action_return (_tmp3_);
}


static void rygel_av_transport_get_transport_settings_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GUPnPServiceAction* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	GUPnPServiceAction* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = action;
	_tmp3_ = rygel_av_transport_get_mode (self);
	_tmp4_ = _tmp3_;
	gupnp_service_action_set (_tmp2_, "PlayMode", G_TYPE_STRING, _tmp4_, "RecQualityMode", G_TYPE_STRING, "NOT_IMPLEMENTED", NULL);
	_tmp5_ = action;
	gupnp_service_action_return (_tmp5_);
}


static void rygel_av_transport_stop_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	RygelMediaPlayer* _tmp2_;
	GUPnPServiceAction* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
#else
	check = 1;
#endif	
	if(check ==1){
		
		_tmp2_ = self->priv->player;
		rygel_media_player_set_playback_state (_tmp2_, "STOPPED");
		_tmp3_ = action;
		gupnp_service_action_return (_tmp3_);
#if defined(CONFIG_RTL_PRE_EMPTIVE)			
		initCurrentOwner();
		ChangeDlnaStateOwner(STATE_NULL);
#endif		
	}else{
		const gchar* _tmp5_ = NULL;
		_tmp5_ = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, _tmp5_);
		}
}

static void rygel_av_transport_play_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int Myright=0;
	gchar* speed = NULL;
	const gchar* _tmp3_;
	RygelMediaPlayer* _tmp6_;
	GUPnPServiceAction* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	if (!rygel_av_transport_check_instance_id (self, action)) {
		return;
	}
	gupnp_service_action_get (action, "Speed", G_TYPE_STRING, &speed, NULL);
	_tmp3_ = speed;
	if (g_strcmp0 (_tmp3_, "1") != 0) {
		const gchar* _tmp5_ = NULL;
		_tmp5_ = _ ("Play speed not supported");
		gupnp_service_action_return_error (action, (guint) 717, _tmp5_);
		_g_free0 (speed);
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)	
	Myright = GetCurrentRight();
#else
	Myright = 1;
#endif	
	if(Myright ==1){
		_tmp6_ = self->priv->player;
		rygel_media_player_set_playback_state (_tmp6_, "PLAYING");	
		gupnp_service_action_return (action);
		_g_free0 (speed);
	}else{
		const gchar* _tmp31_ = NULL;
		_tmp7_ = action;
		_tmp31_ = _ ("Transition not available");
		gupnp_service_action_return_error (_tmp7_, (guint) 701, _tmp31_);
		_g_free0 (speed);
	}

}


static void rygel_av_transport_pause_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	RygelMediaPlayer* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gboolean _tmp6_;
	RygelMediaPlayer* _tmp9_;
	GUPnPServiceAction* _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = self->priv->player;
	_tmp3_ = rygel_media_player_get_playback_state (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strcmp0 (_tmp5_, "PLAYING") != 0;


	_tmp9_ = self->priv->player;

#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
#else
	check = 1;
#endif	
	if(check ==1){

		if (_tmp6_) {

			if( (action->client_UserAgent == PORTABLE)//for QQ
				){
				g_print("<QQ>========== %s(%d) : %s\n",__FUNCTION__,__LINE__,_tmp5_);
			}else{
				GUPnPServiceAction* _tmp7_;
				const gchar* _tmp8_ = NULL;
				
				_tmp7_ = action;
				_tmp8_ = _ ("Transition not available");
				gupnp_service_action_return_error (_tmp7_, (guint) 701, _tmp8_);
				//g_print("===== gupnp_service_action_return_error 701 ===== %s(%d)%s\n"
				//	,__FUNCTION__,__LINE__,_tmp5_);
				_g_free0 (_tmp5_);
				return;
			}
		}

		rygel_media_player_set_playback_state (_tmp9_, "PAUSED_PLAYBACK");
		gupnp_service_action_return (action);
		
	}else{
		const gchar* res = NULL;
		res = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, res);
	}
	
	_g_free0 (_tmp5_);
}


static void rygel_av_transport_seek_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	int check=0;
	Block1Data* _data1_;
	unsigned int CurrentDLNA_FLAGS=0;
	unsigned int CurrentSeekMode=0;
	unsigned int CurrentRendererSeekMode=0;
	GUPnPServiceAction* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gchar* unit = NULL;
	gchar* target = NULL;
	GUPnPServiceAction* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar *_tmp00_=NULL;
	gchar *_tmp00_Seek=NULL;
	GQuark _tmp6_ = 0U;
	static GQuark _tmp5_label0 = 0;
	static GQuark _tmp5_label1 = 0;
	gint64 _tmp20_;
	gint isValid=0;
	gint isSupported=0;
	gchar *default_time_str="0:00:00";
	gint default_time_str_len=strlen(default_time_str);
	GstClockTime _tmp10_ = 0ULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = rygel_av_transport_check_instance_id (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
#if defined(CONFIG_RTL_PRE_EMPTIVE)		
	check = isCurrentServedClient(action);
#else
	check = 1;
#endif	
	if(check ==0){
		const gchar* res = NULL;
		res = _ ("Invalid Action");
		gupnp_service_action_return_error (action, (guint) 401, res);
		return;
	}
	
	_tmp2_ = action;

	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->action = _tmp2_;

	CurrentDLNA_FLAGS = rygel_media_player_get_player_dlna_flags(self->priv->player);
	//g_message("%s %d CurrentDLNA_FLAGS:%08X", __FUNCTION__, __LINE__, CurrentDLNA_FLAGS);
	CurrentSeekMode = 0;
	if ( (CurrentDLNA_FLAGS & GUPNP_DLNA_FLAGS_TIME_BASED_SEEK) == GUPNP_DLNA_FLAGS_TIME_BASED_SEEK) {
		CurrentSeekMode= 2;
	}
	if ((CurrentDLNA_FLAGS & GUPNP_DLNA_FLAGS_BYTE_BASED_SEEK) == GUPNP_DLNA_FLAGS_BYTE_BASED_SEEK) {
		if (CurrentSeekMode > 0) {
			CurrentSeekMode = CurrentSeekMode | 0x1;
		}else
			CurrentSeekMode =1;
	}
	CurrentRendererSeekMode = rygel_media_player_get_renderer_seek_mode(self->priv->player);
	_tmp00_ = rygel_media_player_get_mime_type (self->priv->player);
	_tmp00_Seek = rygel_media_player_get_seek_mode_by_op_param(self->priv->player);
	//g_message("%s %d CurrentSeek:%s", __FUNCTION__, __LINE__,_tmp00_Seek);
	_tmp20_ = rygel_media_player_get_duration_as_time (self->priv->player)/GST_SECOND;
	gupnp_service_action_get (_tmp2_, "Unit", G_TYPE_STRING, &unit, "Target", G_TYPE_STRING, &target, NULL);
	_tmp3_ = unit;
	_tmp4_ = _tmp3_;
//g_message("Mime:%s Seek Unit:%s target:%s, duration:%lld", _tmp00_, unit, target,_tmp20_);
	if (strlen(target) < default_time_str_len)
		isValid = 0;
	else{
		_tmp10_ = rygel_gst_utils_time_from_string (target)/GST_SECOND;
		if (_tmp20_ > 0) {
			if (_tmp10_ > _tmp20_)
				isValid = 0;
			else
				isValid = 1;
		} else
			isValid = 0;
		}
	if (_tmp00_ && strcmp(_tmp00_ , "audio/L16") )
		isSupported = 1;
	else
		isSupported = 0;
	_tmp6_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
	if (!((_tmp6_ == ((0 != _tmp5_label0) ? _tmp5_label0 : (_tmp5_label0 = g_quark_from_static_string ("ABS_TIME")))) || (_tmp6_ == ((0 != _tmp5_label1) ? _tmp5_label1 : (_tmp5_label1 = g_quark_from_static_string ("REL_TIME")))))) {
		isSupported = 0;
	}
	if (!strcmp(_tmp00_Seek, "00") && CurrentSeekMode==0)
		isSupported = 0;
	if (isValid==1 && isSupported ==1 && ((_tmp6_ == ((0 != _tmp5_label0) ? _tmp5_label0 : (_tmp5_label0 = g_quark_from_static_string ("ABS_TIME")))) || (_tmp6_ == ((0 != _tmp5_label1) ? _tmp5_label1 : (_tmp5_label1 = g_quark_from_static_string ("REL_TIME")))))) {
		switch (0) {
			default:
			{
			
			if (CurrentSeekMode > 0 && !strcmp(_tmp00_Seek, "00")) {
				SoupMessage* _tmp11_seek;
				SoupMessage* message;
				SoupMessage* _tmp12_seek;
				SoupMessageHeaders* _tmp13_seek;
				SoupMessage* _tmp14_seek;
				SoupSession* _tmp15_seek;
				SoupMessage* _tmp16_seek;
				SoupMessage* _tmp17_seek;
				_data1_->_uri = rygel_media_player_get_uri (self->priv->player);
				_data1_->_seek_target =g_strdup (target);
				_tmp11_seek = soup_message_new ("HEAD", _data1_->_uri);
				message = _tmp11_seek;
				_tmp12_seek = message;
				_tmp13_seek = _tmp12_seek->request_headers;
				soup_message_headers_append (_tmp13_seek, "getAvailableSeekRange.dlna.org", "1");
				soup_message_headers_append (_tmp13_seek, "Connection", "close");
				_tmp14_seek = message;
				g_signal_connect_data (_tmp14_seek, "finished", (GCallback) ____lambda2_seek_soup_message_finished, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
				_tmp15_seek = self->priv->session;
				_tmp16_seek = message;
				_tmp17_seek = _g_object_ref0 (_tmp16_seek);
				soup_session_queue_message (_tmp15_seek, _tmp17_seek, NULL, NULL);
				_g_object_unref0 (message);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				_g_free0 (target);
				_g_free0 (unit);
				_g_free0 (_tmp00_);
				_g_free0(_tmp00_Seek);
				return;
			}else {

				const gchar* _tmp7_;
				RygelMediaPlayer* _tmp8_;
				const gchar* _tmp9_;
				GstClockTime _tmp10_ = 0ULL;
				gboolean _tmp11_ = FALSE;
				GUPnPServiceAction* _tmp14_;
				_tmp7_ = target;
				g_debug ("Seeking to %s", _tmp7_);
				_tmp8_ = self->priv->player;
				_tmp9_ = target;
				_tmp10_ = rygel_gst_utils_time_from_string (_tmp9_);
				_tmp11_ = rygel_media_player_seek (_tmp8_, _tmp10_);
				if (!_tmp11_) {
					GUPnPServiceAction* _tmp12_;
					const gchar* _tmp13_ = NULL;
					_tmp12_ = action;
					_tmp13_ = _ ("Seek mode not supported");
					gupnp_service_action_return_error (_tmp12_, (guint) 710, _tmp13_);
					_g_free0 (target);
					_g_free0 (unit);
					_g_free0(_tmp00_Seek);
					_g_free0 (_tmp00_);
					block1_data_unref (_data1_);
					_data1_ = NULL;
					return;
				}
				_tmp14_ = action;
				gupnp_service_action_return (_tmp14_);
				_g_free0 (target);
				_g_free0 (unit);
				_g_free0(_tmp00_Seek);
				_g_free0 (_tmp00_);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				return;
			}
			}
		}
	} else {
		switch (0) {
			default:
			{
				GUPnPServiceAction* _tmp15_;
				const gchar* _tmp16_ = NULL;
				if (isSupported == 0) {
					_tmp15_ = action;
					_tmp16_ = _ ("Seek mode not supported");
					gupnp_service_action_return_error (_tmp15_, (guint) 710, _tmp16_);
				} else {
					if (isValid ==0) {
						_tmp15_ = action;
						_tmp16_ = _ ("Illegal Seek Target");
						gupnp_service_action_return_error (_tmp15_, (guint) 711, _tmp16_);
					}
				}
				_g_free0 (target);
				_g_free0 (unit);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				_g_free0 (_tmp00_);
				_g_free0(_tmp00_Seek);
				return;
			}
		}
	}
	_g_free0 (target);
	_g_free0 (unit);
	_g_free0 (_tmp00_);
	_g_free0(_tmp00_Seek);

}


static void rygel_av_transport_next_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = _ ("Illegal Seek target");
	gupnp_service_action_return_error (_tmp0_, (guint) 711, _tmp1_);
}


static void rygel_av_transport_previous_cb (RygelAVTransport* self, GUPnPService* service, GUPnPServiceAction* action) {
	GUPnPServiceAction* _tmp0_;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (service != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = _ ("Illegal Seek target");
	gupnp_service_action_return_error (_tmp0_, (guint) 711, _tmp1_);
}


static void rygel_av_transport_notify_state_cb (RygelAVTransport* self, GObject* player, GParamSpec* p) {
	RygelChangeLog* _tmp0_;
	RygelMediaPlayer* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp7_ = NULL;
	
	g_return_if_fail (self != NULL);
	g_return_if_fail (player != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = self->priv->changelog;
	_tmp1_ = self->priv->player;
	_tmp2_ = rygel_media_player_get_playback_state (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;

#if defined(CONFIG_RTL_PRE_EMPTIVE)
		if(CheckCurrentRight()==0){
			rygel_change_log_log (_tmp0_, "TransportState", "STOPPED");
		}else{
			rygel_change_log_log (_tmp0_, "TransportState", _tmp4_);
		}
#else			
		{
			rygel_change_log_log (_tmp0_, "TransportState", _tmp4_);
		}
#endif
	_tmp7_ = rygel_player_controller_get_current_transport_actions (_tmp1_);
	rygel_change_log_log (_tmp0_, "CurrentTransportActions", _tmp7_);
	_g_free0 (_tmp7_);


	_g_free0 (_tmp4_);
}


static void rygel_av_transport_notify_duration_cb (RygelAVTransport* self, GObject* player, GParamSpec* p) {
	RygelChangeLog* _tmp0_;
	RygelMediaPlayer* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	RygelChangeLog* _tmp5_;
	RygelMediaPlayer* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (player != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = self->priv->changelog;
	_tmp1_ = self->priv->player;
	_tmp2_ = rygel_media_player_get_duration_as_str (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;
	rygel_change_log_log (_tmp0_, "CurrentTrackDuration", _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = self->priv->changelog;
	_tmp6_ = self->priv->player;
	_tmp7_ = rygel_media_player_get_duration_as_str (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = _tmp8_;
	rygel_change_log_log (_tmp5_, "CurrentMediaDuration", _tmp9_);
	_g_free0 (_tmp9_);
}


static void rygel_av_transport_notify_uri_cb (RygelAVTransport* self, GObject* player, GParamSpec* p) {
	RygelChangeLog* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	RygelChangeLog* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (player != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = self->priv->changelog;
	_tmp1_ = rygel_av_transport_get_uri (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	rygel_change_log_log (_tmp0_, "CurrentTrackURI", _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = self->priv->changelog;
	_tmp5_ = rygel_av_transport_get_uri (self);
	_tmp6_ = _tmp5_;
	_tmp7_ = _tmp6_;
	rygel_change_log_log (_tmp4_, "AVTransportURI", _tmp7_);
	_g_free0 (_tmp7_);
}


static void rygel_av_transport_notify_meta_data_cb (RygelAVTransport* self, GObject* player, GParamSpec* p) {
	RygelMediaPlayer* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	RygelChangeLog* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* _tmp32_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (player != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = self->priv->player;
	_tmp1_ = rygel_media_player_get_metadata (_tmp0_);
	_tmp2_ = _tmp1_;
	_g_free0 (self->priv->_metadata);
	self->priv->_metadata = _tmp2_;
	_tmp3_ = self->priv->changelog;
	_tmp4_ = rygel_av_transport_get_metadata (self,1);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	rygel_change_log_log (_tmp3_, "CurrentTrackMetadata", _tmp6_);
	_g_free0 (_tmp6_);

	_tmp30_ = rygel_av_transport_get_metadata (self,1);
	_tmp31_ = _tmp30_;
	_tmp32_ = _tmp31_;
	rygel_change_log_log (_tmp3_, "AVTransportURIMetaData", _tmp32_);
	_g_free0 (_tmp32_);
	
}


RygelAVTransport* rygel_av_transport_construct (GType object_type) {
	RygelAVTransport * self = NULL;
	self = (RygelAVTransport*) g_object_new (object_type, NULL);
	return self;
}


RygelAVTransport* rygel_av_transport_new (void) {
	return rygel_av_transport_construct (RYGEL_TYPE_AV_TRANSPORT);
}


guint rygel_av_transport_get_n_tracks (RygelAVTransport* self) {
	guint result;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_n_tracks;
	result = _tmp0_;
	return result;
}


void rygel_av_transport_set_n_tracks (RygelAVTransport* self, guint value) {
	guint _tmp0_;
	RygelChangeLog* _tmp1_;
	guint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_n_tracks = _tmp0_;
	_tmp1_ = self->priv->changelog;
	_tmp2_ = self->priv->_n_tracks;
	_tmp3_ = g_strdup_printf ("%u", _tmp2_);
	_tmp4_ = _tmp3_;
	rygel_change_log_log (_tmp1_, "NumberOfTracks", _tmp4_);
	_g_free0 (_tmp4_);
	g_object_notify ((GObject *) self, "n-tracks");
}


guint rygel_av_transport_get_track (RygelAVTransport* self) {
	guint result;
	guint _tmp0_;
	gchar* _tmp2_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_track;
	result = _tmp0_;
	_tmp2_ = rygel_media_player_get_playback_state (self->priv->player);
	if (_tmp0_== 0 && !strcmp(_tmp2_, "PLAYING")){
		self->priv->_track = self->priv->_n_tracks;
		result = self->priv->_track;
	}
	_g_free0 (_tmp2_);
	return result;
}


void rygel_av_transport_set_track (RygelAVTransport* self, guint value) {
	guint _tmp0_;
	RygelChangeLog* _tmp1_;
	guint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_track = _tmp0_;
	_tmp1_ = self->priv->changelog;
	_tmp2_ = self->priv->_track;
	_tmp3_ = g_strdup_printf ("%u", _tmp2_);
	_tmp4_ = _tmp3_;
	rygel_change_log_log (_tmp1_, "CurrentTrack", _tmp4_);
	_g_free0 (_tmp4_);
	g_object_notify ((GObject *) self, "track");
}


gchar* rygel_av_transport_get_metadata (RygelAVTransport* self,gint double_escaped) {
	gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_metadata;
	if (_tmp0_ != NULL) {
		const gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp33_ = NULL;
		_tmp1_ = self->priv->_metadata;
		if (double_escaped ==1) {
			_tmp2_ = g_markup_escape_text (_tmp1_, (gssize) (-1));
			_tmp33_ = g_markup_escape_text (_tmp2_, (gssize) (-1));
			_g_free0 (_tmp2_);
			result = _tmp33_;
		}else if (double_escaped ==0) {
			_tmp2_ = g_markup_escape_text (_tmp1_, (gssize) (-1));
			result = _tmp2_;
		}
		return result;
	} else {
		gchar* _tmp3_;
		_tmp3_ = g_strdup ("");
		result = _tmp3_;
		return result;
	}
}


void rygel_av_transport_set_metadata (RygelAVTransport* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	RygelMediaPlayer* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_metadata);
	self->priv->_metadata = _tmp1_;
	_tmp2_ = self->priv->player;
	_tmp3_ = value;
	rygel_media_player_set_metadata (_tmp2_, _tmp3_);
	g_object_notify ((GObject *) self, "metadata");
}


gchar* rygel_av_transport_get_uri (RygelAVTransport* self) {
	gchar* result;
	RygelMediaPlayer* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->player;
	_tmp1_ = rygel_media_player_get_uri (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_ != NULL;
	_g_free0 (_tmp3_);
	if (_tmp4_) {
		RygelMediaPlayer* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp5_ = self->priv->player;
		_tmp6_ = rygel_media_player_get_uri (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = _tmp7_;
		_tmp9_ = g_markup_escape_text (_tmp8_, (gssize) (-1));
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		result = _tmp10_;
		return result;
	} else {
		gchar* _tmp11_;
		_tmp11_ = g_strdup ("");
		result = _tmp11_;
		return result;
	}
}


void rygel_av_transport_set_uri (RygelAVTransport* self, const gchar* value) {
	RygelMediaPlayer* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->player;
	_tmp1_ = value;
	rygel_media_player_set_uri (_tmp0_, _tmp1_);
	g_object_notify ((GObject *) self, "uri");
}


const gchar* rygel_av_transport_get_status (RygelAVTransport* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_status;
	result = _tmp0_;
	return result;
}


void rygel_av_transport_set_status (RygelAVTransport* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	RygelChangeLog* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_status);
	self->priv->_status = _tmp1_;
	_tmp2_ = self->priv->changelog;
	_tmp3_ = self->priv->_status;
	rygel_change_log_log (_tmp2_, "TransportStatus", _tmp3_);
	g_object_notify ((GObject *) self, "status");
}


const gchar* rygel_av_transport_get_speed (RygelAVTransport* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_speed;
	result = _tmp0_;
	return result;
}


void rygel_av_transport_set_speed (RygelAVTransport* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	RygelChangeLog* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_speed);
	self->priv->_speed = _tmp1_;
	_tmp2_ = self->priv->changelog;
	_tmp3_ = self->priv->_speed;
	rygel_change_log_log (_tmp2_, "TransportPlaySpeed", _tmp3_);
	g_object_notify ((GObject *) self, "speed");
}


const gchar* rygel_av_transport_get_mode (RygelAVTransport* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_mode;
	result = _tmp0_;
	return result;
}


void rygel_av_transport_set_mode (RygelAVTransport* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	RygelChangeLog* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_mode);
	self->priv->_mode = _tmp1_;
	_tmp2_ = self->priv->changelog;
	_tmp3_ = self->priv->_mode;
	rygel_change_log_log (_tmp2_, "CurrentPlayMode", _tmp3_);
	g_object_notify ((GObject *) self, "mode");
}


static void rygel_av_transport_class_init (RygelAVTransportClass * klass) {
	rygel_av_transport_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RygelAVTransportPrivate));
	G_OBJECT_CLASS (klass)->constructed = rygel_av_transport_real_constructed;
	G_OBJECT_CLASS (klass)->get_property = _vala_rygel_av_transport_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_rygel_av_transport_set_property;
	G_OBJECT_CLASS (klass)->finalize = rygel_av_transport_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_N_TRACKS, g_param_spec_uint ("n-tracks", "n-tracks", "n-tracks", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_TRACK, g_param_spec_uint ("track", "track", "track", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_METADATA, g_param_spec_string ("metadata", "metadata", "metadata", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_URI, g_param_spec_string ("uri", "uri", "uri", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_STATUS, g_param_spec_string ("status", "status", "status", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_SPEED, g_param_spec_string ("speed", "speed", "speed", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_AV_TRANSPORT_MODE, g_param_spec_string ("mode", "mode", "mode", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void rygel_av_transport_instance_init (RygelAVTransport * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	self->priv = RYGEL_AV_TRANSPORT_GET_PRIVATE (self);
	self->priv->_n_tracks = (guint) 0;
	self->priv->_track = (guint) 0;
	_tmp0_ = g_strdup ("");
	self->priv->_metadata = _tmp0_;
	_tmp1_ = g_strdup ("OK");
	self->priv->_status = _tmp1_;
	_tmp2_ = g_strdup ("1");
	self->priv->_speed = _tmp2_;
	_tmp3_ = g_strdup ("NORMAL");
	self->priv->_mode = _tmp3_;
}


static void rygel_av_transport_finalize (GObject* obj) {
	RygelAVTransport * self;
	self = RYGEL_AV_TRANSPORT (obj);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->_metadata);
	_g_free0 (self->priv->_status);
	_g_free0 (self->priv->_speed);
	_g_free0 (self->priv->_mode);
	_g_object_unref0 (self->priv->changelog);
	_g_object_unref0 (self->priv->player);
	G_OBJECT_CLASS (rygel_av_transport_parent_class)->finalize (obj);
}


GType rygel_av_transport_get_type (void) {
	static volatile gsize rygel_av_transport_type_id__volatile = 0;
	if (g_once_init_enter (&rygel_av_transport_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RygelAVTransportClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_av_transport_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelAVTransport), 0, (GInstanceInitFunc) rygel_av_transport_instance_init, NULL };
		GType rygel_av_transport_type_id;
		rygel_av_transport_type_id = g_type_register_static (GUPNP_TYPE_SERVICE, "RygelAVTransport", &g_define_type_info, 0);
		g_once_init_leave (&rygel_av_transport_type_id__volatile, rygel_av_transport_type_id);
	}
	return rygel_av_transport_type_id__volatile;
}


static void _vala_rygel_av_transport_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RygelAVTransport * self;
	self = RYGEL_AV_TRANSPORT (object);
	switch (property_id) {
		case RYGEL_AV_TRANSPORT_N_TRACKS:
		g_value_set_uint (value, rygel_av_transport_get_n_tracks (self));
		break;
		case RYGEL_AV_TRANSPORT_TRACK:
		g_value_set_uint (value, rygel_av_transport_get_track (self));
		break;
		case RYGEL_AV_TRANSPORT_METADATA:
		g_value_take_string (value, rygel_av_transport_get_metadata (self,0));
		break;
		case RYGEL_AV_TRANSPORT_URI:
		g_value_take_string (value, rygel_av_transport_get_uri (self));
		break;
		case RYGEL_AV_TRANSPORT_STATUS:
		g_value_set_string (value, rygel_av_transport_get_status (self));
		break;
		case RYGEL_AV_TRANSPORT_SPEED:
		g_value_set_string (value, rygel_av_transport_get_speed (self));
		break;
		case RYGEL_AV_TRANSPORT_MODE:
		g_value_set_string (value, rygel_av_transport_get_mode (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_rygel_av_transport_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RygelAVTransport * self;
	self = RYGEL_AV_TRANSPORT (object);
	switch (property_id) {
		case RYGEL_AV_TRANSPORT_N_TRACKS:
		rygel_av_transport_set_n_tracks (self, g_value_get_uint (value));
		break;
		case RYGEL_AV_TRANSPORT_TRACK:
		rygel_av_transport_set_track (self, g_value_get_uint (value));
		break;
		case RYGEL_AV_TRANSPORT_METADATA:
		rygel_av_transport_set_metadata (self, g_value_get_string (value));
		break;
		case RYGEL_AV_TRANSPORT_URI:
		rygel_av_transport_set_uri (self, g_value_get_string (value));
		break;
		case RYGEL_AV_TRANSPORT_STATUS:
		rygel_av_transport_set_status (self, g_value_get_string (value));
		break;
		case RYGEL_AV_TRANSPORT_SPEED:
		rygel_av_transport_set_speed (self, g_value_get_string (value));
		break;
		case RYGEL_AV_TRANSPORT_MODE:
		rygel_av_transport_set_mode (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



